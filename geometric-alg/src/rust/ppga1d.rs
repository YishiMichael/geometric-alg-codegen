// Automatically generated by `geometric-alg-codegen`
use crate::traits::*;

#[derive(Clone, Copy, Debug, Default)]
pub struct Scalar {
    pub s: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Vector {
    pub e0: f32,
    pub e1: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Bivector {
    pub e01: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Null;

#[derive(Clone, Copy, Debug, Default)]
pub struct OddMultivector {
    pub e0: f32,
    pub e1: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct EvenMultivector {
    pub s: f32,
    pub e01: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Multivector {
    pub s: f32,
    pub e0: f32,
    pub e1: f32,
    pub e01: f32,
}

impl From<Scalar> for Vector {
    fn from(value: Scalar) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<Scalar> for Bivector {
    fn from(value: Scalar) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl From<Scalar> for Null {
    fn from(value: Scalar) -> Null {
        Null
    }
}

impl From<Scalar> for OddMultivector {
    fn from(value: Scalar) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<Scalar> for EvenMultivector {
    fn from(value: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: value.s,
            e01: 0.0,
        }
    }
}

impl From<Scalar> for Multivector {
    fn from(value: Scalar) -> Multivector {
        Multivector {
            s: value.s,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl From<Scalar> for f32 {
    fn from(value: Scalar) -> f32 {
        value.s
    }
}

impl From<Vector> for Scalar {
    fn from(value: Vector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<Vector> for Bivector {
    fn from(value: Vector) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl From<Vector> for Null {
    fn from(value: Vector) -> Null {
        Null
    }
}

impl From<Vector> for OddMultivector {
    fn from(value: Vector) -> OddMultivector {
        OddMultivector {
            e0: value.e0,
            e1: value.e1,
        }
    }
}

impl From<Vector> for EvenMultivector {
    fn from(value: Vector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl From<Vector> for Multivector {
    fn from(value: Vector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: value.e0,
            e1: value.e1,
            e01: 0.0,
        }
    }
}

impl From<Vector> for f32 {
    fn from(value: Vector) -> f32 {
        0.0
    }
}

impl From<Bivector> for Scalar {
    fn from(value: Bivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<Bivector> for Vector {
    fn from(value: Bivector) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<Bivector> for Null {
    fn from(value: Bivector) -> Null {
        Null
    }
}

impl From<Bivector> for OddMultivector {
    fn from(value: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<Bivector> for EvenMultivector {
    fn from(value: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: value.e01,
        }
    }
}

impl From<Bivector> for Multivector {
    fn from(value: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: value.e01,
        }
    }
}

impl From<Bivector> for f32 {
    fn from(value: Bivector) -> f32 {
        0.0
    }
}

impl From<Null> for Scalar {
    fn from(value: Null) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<Null> for Vector {
    fn from(value: Null) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<Null> for Bivector {
    fn from(value: Null) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl From<Null> for OddMultivector {
    fn from(value: Null) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<Null> for EvenMultivector {
    fn from(value: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl From<Null> for Multivector {
    fn from(value: Null) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl From<Null> for f32 {
    fn from(value: Null) -> f32 {
        0.0
    }
}

impl From<OddMultivector> for Scalar {
    fn from(value: OddMultivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<OddMultivector> for Vector {
    fn from(value: OddMultivector) -> Vector {
        Vector {
            e0: value.e0,
            e1: value.e1,
        }
    }
}

impl From<OddMultivector> for Bivector {
    fn from(value: OddMultivector) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl From<OddMultivector> for Null {
    fn from(value: OddMultivector) -> Null {
        Null
    }
}

impl From<OddMultivector> for EvenMultivector {
    fn from(value: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl From<OddMultivector> for Multivector {
    fn from(value: OddMultivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: value.e0,
            e1: value.e1,
            e01: 0.0,
        }
    }
}

impl From<OddMultivector> for f32 {
    fn from(value: OddMultivector) -> f32 {
        0.0
    }
}

impl From<EvenMultivector> for Scalar {
    fn from(value: EvenMultivector) -> Scalar {
        Scalar {
            s: value.s,
        }
    }
}

impl From<EvenMultivector> for Vector {
    fn from(value: EvenMultivector) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<EvenMultivector> for Bivector {
    fn from(value: EvenMultivector) -> Bivector {
        Bivector {
            e01: value.e01,
        }
    }
}

impl From<EvenMultivector> for Null {
    fn from(value: EvenMultivector) -> Null {
        Null
    }
}

impl From<EvenMultivector> for OddMultivector {
    fn from(value: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<EvenMultivector> for Multivector {
    fn from(value: EvenMultivector) -> Multivector {
        Multivector {
            s: value.s,
            e0: 0.0,
            e1: 0.0,
            e01: value.e01,
        }
    }
}

impl From<EvenMultivector> for f32 {
    fn from(value: EvenMultivector) -> f32 {
        value.s
    }
}

impl From<Multivector> for Scalar {
    fn from(value: Multivector) -> Scalar {
        Scalar {
            s: value.s,
        }
    }
}

impl From<Multivector> for Vector {
    fn from(value: Multivector) -> Vector {
        Vector {
            e0: value.e0,
            e1: value.e1,
        }
    }
}

impl From<Multivector> for Bivector {
    fn from(value: Multivector) -> Bivector {
        Bivector {
            e01: value.e01,
        }
    }
}

impl From<Multivector> for Null {
    fn from(value: Multivector) -> Null {
        Null
    }
}

impl From<Multivector> for OddMultivector {
    fn from(value: Multivector) -> OddMultivector {
        OddMultivector {
            e0: value.e0,
            e1: value.e1,
        }
    }
}

impl From<Multivector> for EvenMultivector {
    fn from(value: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: value.s,
            e01: value.e01,
        }
    }
}

impl From<Multivector> for f32 {
    fn from(value: Multivector) -> f32 {
        value.s
    }
}

impl From<f32> for Scalar {
    fn from(value: f32) -> Scalar {
        Scalar {
            s: value,
        }
    }
}

impl From<f32> for Vector {
    fn from(value: f32) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<f32> for Bivector {
    fn from(value: f32) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl From<f32> for Null {
    fn from(value: f32) -> Null {
        Null
    }
}

impl From<f32> for OddMultivector {
    fn from(value: f32) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl From<f32> for EvenMultivector {
    fn from(value: f32) -> EvenMultivector {
        EvenMultivector {
            s: value,
            e01: 0.0,
        }
    }
}

impl From<f32> for Multivector {
    fn from(value: f32) -> Multivector {
        Multivector {
            s: value,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Neg for Scalar {
    type Output = Scalar;
    fn neg(self) -> Scalar {
        Scalar {
            s: -self.s,
        }
    }
}

impl Neg for Vector {
    type Output = Vector;
    fn neg(self) -> Vector {
        Vector {
            e0: -self.e0,
            e1: -self.e1,
        }
    }
}

impl Neg for Bivector {
    type Output = Bivector;
    fn neg(self) -> Bivector {
        Bivector {
            e01: -self.e01,
        }
    }
}

impl Neg for Null {
    type Output = Null;
    fn neg(self) -> Null {
        Null
    }
}

impl Neg for OddMultivector {
    type Output = OddMultivector;
    fn neg(self) -> OddMultivector {
        OddMultivector {
            e0: -self.e0,
            e1: -self.e1,
        }
    }
}

impl Neg for EvenMultivector {
    type Output = EvenMultivector;
    fn neg(self) -> EvenMultivector {
        EvenMultivector {
            s: -self.s,
            e01: -self.e01,
        }
    }
}

impl Neg for Multivector {
    type Output = Multivector;
    fn neg(self) -> Multivector {
        Multivector {
            s: -self.s,
            e0: -self.e0,
            e1: -self.e1,
            e01: -self.e01,
        }
    }
}

impl Add<Scalar> for Scalar {
    type Output = Scalar;
    fn add(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s + other.s,
        }
    }
}

impl Add<Vector> for Vector {
    type Output = Vector;
    fn add(self, other: Vector) -> Vector {
        Vector {
            e0: self.e0 + other.e0,
            e1: self.e1 + other.e1,
        }
    }
}

impl Add<Bivector> for Bivector {
    type Output = Bivector;
    fn add(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self.e01 + other.e01,
        }
    }
}

impl Add<Null> for Null {
    type Output = Null;
    fn add(self, other: Null) -> Null {
        Null
    }
}

impl Add<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn add(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 + other.e0,
            e1: self.e1 + other.e1,
        }
    }
}

impl Add<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn add(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s + other.s,
            e01: self.e01 + other.e01,
        }
    }
}

impl Add<Multivector> for Multivector {
    type Output = Multivector;
    fn add(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s + other.s,
            e0: self.e0 + other.e0,
            e1: self.e1 + other.e1,
            e01: self.e01 + other.e01,
        }
    }
}

impl Add<f32> for Scalar {
    type Output = Scalar;
    fn add(self, other: f32) -> Scalar {
        Scalar {
            s: self.s + other,
        }
    }
}

impl Add<f32> for Vector {
    type Output = Vector;
    fn add(self, other: f32) -> Vector {
        Vector {
            e0: self.e0 + other,
            e1: self.e1 + other,
        }
    }
}

impl Add<f32> for Bivector {
    type Output = Bivector;
    fn add(self, other: f32) -> Bivector {
        Bivector {
            e01: self.e01 + other,
        }
    }
}

impl Add<f32> for Null {
    type Output = Null;
    fn add(self, other: f32) -> Null {
        Null
    }
}

impl Add<f32> for OddMultivector {
    type Output = OddMultivector;
    fn add(self, other: f32) -> OddMultivector {
        OddMultivector {
            e0: self.e0 + other,
            e1: self.e1 + other,
        }
    }
}

impl Add<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn add(self, other: f32) -> EvenMultivector {
        EvenMultivector {
            s: self.s + other,
            e01: self.e01 + other,
        }
    }
}

impl Add<f32> for Multivector {
    type Output = Multivector;
    fn add(self, other: f32) -> Multivector {
        Multivector {
            s: self.s + other,
            e0: self.e0 + other,
            e1: self.e1 + other,
            e01: self.e01 + other,
        }
    }
}

impl Add<Scalar> for f32 {
    type Output = Scalar;
    fn add(self, other: Scalar) -> Scalar {
        Scalar {
            s: self + other.s,
        }
    }
}

impl Add<Vector> for f32 {
    type Output = Vector;
    fn add(self, other: Vector) -> Vector {
        Vector {
            e0: self + other.e0,
            e1: self + other.e1,
        }
    }
}

impl Add<Bivector> for f32 {
    type Output = Bivector;
    fn add(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self + other.e01,
        }
    }
}

impl Add<Null> for f32 {
    type Output = Null;
    fn add(self, other: Null) -> Null {
        Null
    }
}

impl Add<OddMultivector> for f32 {
    type Output = OddMultivector;
    fn add(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self + other.e0,
            e1: self + other.e1,
        }
    }
}

impl Add<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn add(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self + other.s,
            e01: self + other.e01,
        }
    }
}

impl Add<Multivector> for f32 {
    type Output = Multivector;
    fn add(self, other: Multivector) -> Multivector {
        Multivector {
            s: self + other.s,
            e0: self + other.e0,
            e1: self + other.e1,
            e01: self + other.e01,
        }
    }
}

impl Sub<Scalar> for Scalar {
    type Output = Scalar;
    fn sub(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s - other.s,
        }
    }
}

impl Sub<Vector> for Vector {
    type Output = Vector;
    fn sub(self, other: Vector) -> Vector {
        Vector {
            e0: self.e0 - other.e0,
            e1: self.e1 - other.e1,
        }
    }
}

impl Sub<Bivector> for Bivector {
    type Output = Bivector;
    fn sub(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self.e01 - other.e01,
        }
    }
}

impl Sub<Null> for Null {
    type Output = Null;
    fn sub(self, other: Null) -> Null {
        Null
    }
}

impl Sub<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn sub(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 - other.e0,
            e1: self.e1 - other.e1,
        }
    }
}

impl Sub<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn sub(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s - other.s,
            e01: self.e01 - other.e01,
        }
    }
}

impl Sub<Multivector> for Multivector {
    type Output = Multivector;
    fn sub(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s - other.s,
            e0: self.e0 - other.e0,
            e1: self.e1 - other.e1,
            e01: self.e01 - other.e01,
        }
    }
}

impl Sub<f32> for Scalar {
    type Output = Scalar;
    fn sub(self, other: f32) -> Scalar {
        Scalar {
            s: self.s - other,
        }
    }
}

impl Sub<f32> for Vector {
    type Output = Vector;
    fn sub(self, other: f32) -> Vector {
        Vector {
            e0: self.e0 - other,
            e1: self.e1 - other,
        }
    }
}

impl Sub<f32> for Bivector {
    type Output = Bivector;
    fn sub(self, other: f32) -> Bivector {
        Bivector {
            e01: self.e01 - other,
        }
    }
}

impl Sub<f32> for Null {
    type Output = Null;
    fn sub(self, other: f32) -> Null {
        Null
    }
}

impl Sub<f32> for OddMultivector {
    type Output = OddMultivector;
    fn sub(self, other: f32) -> OddMultivector {
        OddMultivector {
            e0: self.e0 - other,
            e1: self.e1 - other,
        }
    }
}

impl Sub<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn sub(self, other: f32) -> EvenMultivector {
        EvenMultivector {
            s: self.s - other,
            e01: self.e01 - other,
        }
    }
}

impl Sub<f32> for Multivector {
    type Output = Multivector;
    fn sub(self, other: f32) -> Multivector {
        Multivector {
            s: self.s - other,
            e0: self.e0 - other,
            e1: self.e1 - other,
            e01: self.e01 - other,
        }
    }
}

impl Sub<Scalar> for f32 {
    type Output = Scalar;
    fn sub(self, other: Scalar) -> Scalar {
        Scalar {
            s: self - other.s,
        }
    }
}

impl Sub<Vector> for f32 {
    type Output = Vector;
    fn sub(self, other: Vector) -> Vector {
        Vector {
            e0: self - other.e0,
            e1: self - other.e1,
        }
    }
}

impl Sub<Bivector> for f32 {
    type Output = Bivector;
    fn sub(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self - other.e01,
        }
    }
}

impl Sub<Null> for f32 {
    type Output = Null;
    fn sub(self, other: Null) -> Null {
        Null
    }
}

impl Sub<OddMultivector> for f32 {
    type Output = OddMultivector;
    fn sub(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self - other.e0,
            e1: self - other.e1,
        }
    }
}

impl Sub<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn sub(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self - other.s,
            e01: self - other.e01,
        }
    }
}

impl Sub<Multivector> for f32 {
    type Output = Multivector;
    fn sub(self, other: Multivector) -> Multivector {
        Multivector {
            s: self - other.s,
            e0: self - other.e0,
            e1: self - other.e1,
            e01: self - other.e01,
        }
    }
}

impl Mul<Scalar> for Scalar {
    type Output = Scalar;
    fn mul(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s * other.s,
        }
    }
}

impl Mul<Vector> for Vector {
    type Output = Vector;
    fn mul(self, other: Vector) -> Vector {
        Vector {
            e0: self.e0 * other.e0,
            e1: self.e1 * other.e1,
        }
    }
}

impl Mul<Bivector> for Bivector {
    type Output = Bivector;
    fn mul(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self.e01 * other.e01,
        }
    }
}

impl Mul<Null> for Null {
    type Output = Null;
    fn mul(self, other: Null) -> Null {
        Null
    }
}

impl Mul<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn mul(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.e0,
            e1: self.e1 * other.e1,
        }
    }
}

impl Mul<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn mul(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.e01 * other.e01,
        }
    }
}

impl Mul<Multivector> for Multivector {
    type Output = Multivector;
    fn mul(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.e0,
            e1: self.e1 * other.e1,
            e01: self.e01 * other.e01,
        }
    }
}

impl Mul<f32> for Scalar {
    type Output = Scalar;
    fn mul(self, other: f32) -> Scalar {
        Scalar {
            s: self.s * other,
        }
    }
}

impl Mul<f32> for Vector {
    type Output = Vector;
    fn mul(self, other: f32) -> Vector {
        Vector {
            e0: self.e0 * other,
            e1: self.e1 * other,
        }
    }
}

impl Mul<f32> for Bivector {
    type Output = Bivector;
    fn mul(self, other: f32) -> Bivector {
        Bivector {
            e01: self.e01 * other,
        }
    }
}

impl Mul<f32> for Null {
    type Output = Null;
    fn mul(self, other: f32) -> Null {
        Null
    }
}

impl Mul<f32> for OddMultivector {
    type Output = OddMultivector;
    fn mul(self, other: f32) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other,
            e1: self.e1 * other,
        }
    }
}

impl Mul<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn mul(self, other: f32) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other,
            e01: self.e01 * other,
        }
    }
}

impl Mul<f32> for Multivector {
    type Output = Multivector;
    fn mul(self, other: f32) -> Multivector {
        Multivector {
            s: self.s * other,
            e0: self.e0 * other,
            e1: self.e1 * other,
            e01: self.e01 * other,
        }
    }
}

impl Mul<Scalar> for f32 {
    type Output = Scalar;
    fn mul(self, other: Scalar) -> Scalar {
        Scalar {
            s: self * other.s,
        }
    }
}

impl Mul<Vector> for f32 {
    type Output = Vector;
    fn mul(self, other: Vector) -> Vector {
        Vector {
            e0: self * other.e0,
            e1: self * other.e1,
        }
    }
}

impl Mul<Bivector> for f32 {
    type Output = Bivector;
    fn mul(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self * other.e01,
        }
    }
}

impl Mul<Null> for f32 {
    type Output = Null;
    fn mul(self, other: Null) -> Null {
        Null
    }
}

impl Mul<OddMultivector> for f32 {
    type Output = OddMultivector;
    fn mul(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self * other.e0,
            e1: self * other.e1,
        }
    }
}

impl Mul<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn mul(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self * other.s,
            e01: self * other.e01,
        }
    }
}

impl Mul<Multivector> for f32 {
    type Output = Multivector;
    fn mul(self, other: Multivector) -> Multivector {
        Multivector {
            s: self * other.s,
            e0: self * other.e0,
            e1: self * other.e1,
            e01: self * other.e01,
        }
    }
}

impl Div<Scalar> for Scalar {
    type Output = Scalar;
    fn div(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s / other.s,
        }
    }
}

impl Div<Vector> for Vector {
    type Output = Vector;
    fn div(self, other: Vector) -> Vector {
        Vector {
            e0: self.e0 / other.e0,
            e1: self.e1 / other.e1,
        }
    }
}

impl Div<Bivector> for Bivector {
    type Output = Bivector;
    fn div(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self.e01 / other.e01,
        }
    }
}

impl Div<Null> for Null {
    type Output = Null;
    fn div(self, other: Null) -> Null {
        Null
    }
}

impl Div<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn div(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 / other.e0,
            e1: self.e1 / other.e1,
        }
    }
}

impl Div<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn div(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s / other.s,
            e01: self.e01 / other.e01,
        }
    }
}

impl Div<Multivector> for Multivector {
    type Output = Multivector;
    fn div(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s / other.s,
            e0: self.e0 / other.e0,
            e1: self.e1 / other.e1,
            e01: self.e01 / other.e01,
        }
    }
}

impl Div<f32> for Scalar {
    type Output = Scalar;
    fn div(self, other: f32) -> Scalar {
        Scalar {
            s: self.s / other,
        }
    }
}

impl Div<f32> for Vector {
    type Output = Vector;
    fn div(self, other: f32) -> Vector {
        Vector {
            e0: self.e0 / other,
            e1: self.e1 / other,
        }
    }
}

impl Div<f32> for Bivector {
    type Output = Bivector;
    fn div(self, other: f32) -> Bivector {
        Bivector {
            e01: self.e01 / other,
        }
    }
}

impl Div<f32> for Null {
    type Output = Null;
    fn div(self, other: f32) -> Null {
        Null
    }
}

impl Div<f32> for OddMultivector {
    type Output = OddMultivector;
    fn div(self, other: f32) -> OddMultivector {
        OddMultivector {
            e0: self.e0 / other,
            e1: self.e1 / other,
        }
    }
}

impl Div<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn div(self, other: f32) -> EvenMultivector {
        EvenMultivector {
            s: self.s / other,
            e01: self.e01 / other,
        }
    }
}

impl Div<f32> for Multivector {
    type Output = Multivector;
    fn div(self, other: f32) -> Multivector {
        Multivector {
            s: self.s / other,
            e0: self.e0 / other,
            e1: self.e1 / other,
            e01: self.e01 / other,
        }
    }
}

impl Div<Scalar> for f32 {
    type Output = Scalar;
    fn div(self, other: Scalar) -> Scalar {
        Scalar {
            s: self / other.s,
        }
    }
}

impl Div<Vector> for f32 {
    type Output = Vector;
    fn div(self, other: Vector) -> Vector {
        Vector {
            e0: self / other.e0,
            e1: self / other.e1,
        }
    }
}

impl Div<Bivector> for f32 {
    type Output = Bivector;
    fn div(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self / other.e01,
        }
    }
}

impl Div<Null> for f32 {
    type Output = Null;
    fn div(self, other: Null) -> Null {
        Null
    }
}

impl Div<OddMultivector> for f32 {
    type Output = OddMultivector;
    fn div(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self / other.e0,
            e1: self / other.e1,
        }
    }
}

impl Div<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn div(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self / other.s,
            e01: self / other.e01,
        }
    }
}

impl Div<Multivector> for f32 {
    type Output = Multivector;
    fn div(self, other: Multivector) -> Multivector {
        Multivector {
            s: self / other.s,
            e0: self / other.e0,
            e1: self / other.e1,
            e01: self / other.e01,
        }
    }
}

impl AddAssign<Scalar> for Scalar {
    fn add_assign(&mut self, other: Scalar) {
        self.s += other.s;
    }
}

impl AddAssign<Vector> for Vector {
    fn add_assign(&mut self, other: Vector) {
        self.e0 += other.e0;
        self.e1 += other.e1;
    }
}

impl AddAssign<Bivector> for Bivector {
    fn add_assign(&mut self, other: Bivector) {
        self.e01 += other.e01;
    }
}

impl AddAssign<Null> for Null {
    fn add_assign(&mut self, other: Null) {
    }
}

impl AddAssign<OddMultivector> for OddMultivector {
    fn add_assign(&mut self, other: OddMultivector) {
        self.e0 += other.e0;
        self.e1 += other.e1;
    }
}

impl AddAssign<EvenMultivector> for EvenMultivector {
    fn add_assign(&mut self, other: EvenMultivector) {
        self.s += other.s;
        self.e01 += other.e01;
    }
}

impl AddAssign<Multivector> for Multivector {
    fn add_assign(&mut self, other: Multivector) {
        self.s += other.s;
        self.e0 += other.e0;
        self.e1 += other.e1;
        self.e01 += other.e01;
    }
}

impl AddAssign<f32> for Scalar {
    fn add_assign(&mut self, other: f32) {
        self.s += other;
    }
}

impl AddAssign<f32> for Vector {
    fn add_assign(&mut self, other: f32) {
        self.e0 += other;
        self.e1 += other;
    }
}

impl AddAssign<f32> for Bivector {
    fn add_assign(&mut self, other: f32) {
        self.e01 += other;
    }
}

impl AddAssign<f32> for Null {
    fn add_assign(&mut self, other: f32) {
    }
}

impl AddAssign<f32> for OddMultivector {
    fn add_assign(&mut self, other: f32) {
        self.e0 += other;
        self.e1 += other;
    }
}

impl AddAssign<f32> for EvenMultivector {
    fn add_assign(&mut self, other: f32) {
        self.s += other;
        self.e01 += other;
    }
}

impl AddAssign<f32> for Multivector {
    fn add_assign(&mut self, other: f32) {
        self.s += other;
        self.e0 += other;
        self.e1 += other;
        self.e01 += other;
    }
}

impl SubAssign<Scalar> for Scalar {
    fn sub_assign(&mut self, other: Scalar) {
        self.s -= other.s;
    }
}

impl SubAssign<Vector> for Vector {
    fn sub_assign(&mut self, other: Vector) {
        self.e0 -= other.e0;
        self.e1 -= other.e1;
    }
}

impl SubAssign<Bivector> for Bivector {
    fn sub_assign(&mut self, other: Bivector) {
        self.e01 -= other.e01;
    }
}

impl SubAssign<Null> for Null {
    fn sub_assign(&mut self, other: Null) {
    }
}

impl SubAssign<OddMultivector> for OddMultivector {
    fn sub_assign(&mut self, other: OddMultivector) {
        self.e0 -= other.e0;
        self.e1 -= other.e1;
    }
}

impl SubAssign<EvenMultivector> for EvenMultivector {
    fn sub_assign(&mut self, other: EvenMultivector) {
        self.s -= other.s;
        self.e01 -= other.e01;
    }
}

impl SubAssign<Multivector> for Multivector {
    fn sub_assign(&mut self, other: Multivector) {
        self.s -= other.s;
        self.e0 -= other.e0;
        self.e1 -= other.e1;
        self.e01 -= other.e01;
    }
}

impl SubAssign<f32> for Scalar {
    fn sub_assign(&mut self, other: f32) {
        self.s -= other;
    }
}

impl SubAssign<f32> for Vector {
    fn sub_assign(&mut self, other: f32) {
        self.e0 -= other;
        self.e1 -= other;
    }
}

impl SubAssign<f32> for Bivector {
    fn sub_assign(&mut self, other: f32) {
        self.e01 -= other;
    }
}

impl SubAssign<f32> for Null {
    fn sub_assign(&mut self, other: f32) {
    }
}

impl SubAssign<f32> for OddMultivector {
    fn sub_assign(&mut self, other: f32) {
        self.e0 -= other;
        self.e1 -= other;
    }
}

impl SubAssign<f32> for EvenMultivector {
    fn sub_assign(&mut self, other: f32) {
        self.s -= other;
        self.e01 -= other;
    }
}

impl SubAssign<f32> for Multivector {
    fn sub_assign(&mut self, other: f32) {
        self.s -= other;
        self.e0 -= other;
        self.e1 -= other;
        self.e01 -= other;
    }
}

impl MulAssign<Scalar> for Scalar {
    fn mul_assign(&mut self, other: Scalar) {
        self.s *= other.s;
    }
}

impl MulAssign<Vector> for Vector {
    fn mul_assign(&mut self, other: Vector) {
        self.e0 *= other.e0;
        self.e1 *= other.e1;
    }
}

impl MulAssign<Bivector> for Bivector {
    fn mul_assign(&mut self, other: Bivector) {
        self.e01 *= other.e01;
    }
}

impl MulAssign<Null> for Null {
    fn mul_assign(&mut self, other: Null) {
    }
}

impl MulAssign<OddMultivector> for OddMultivector {
    fn mul_assign(&mut self, other: OddMultivector) {
        self.e0 *= other.e0;
        self.e1 *= other.e1;
    }
}

impl MulAssign<EvenMultivector> for EvenMultivector {
    fn mul_assign(&mut self, other: EvenMultivector) {
        self.s *= other.s;
        self.e01 *= other.e01;
    }
}

impl MulAssign<Multivector> for Multivector {
    fn mul_assign(&mut self, other: Multivector) {
        self.s *= other.s;
        self.e0 *= other.e0;
        self.e1 *= other.e1;
        self.e01 *= other.e01;
    }
}

impl MulAssign<f32> for Scalar {
    fn mul_assign(&mut self, other: f32) {
        self.s *= other;
    }
}

impl MulAssign<f32> for Vector {
    fn mul_assign(&mut self, other: f32) {
        self.e0 *= other;
        self.e1 *= other;
    }
}

impl MulAssign<f32> for Bivector {
    fn mul_assign(&mut self, other: f32) {
        self.e01 *= other;
    }
}

impl MulAssign<f32> for Null {
    fn mul_assign(&mut self, other: f32) {
    }
}

impl MulAssign<f32> for OddMultivector {
    fn mul_assign(&mut self, other: f32) {
        self.e0 *= other;
        self.e1 *= other;
    }
}

impl MulAssign<f32> for EvenMultivector {
    fn mul_assign(&mut self, other: f32) {
        self.s *= other;
        self.e01 *= other;
    }
}

impl MulAssign<f32> for Multivector {
    fn mul_assign(&mut self, other: f32) {
        self.s *= other;
        self.e0 *= other;
        self.e1 *= other;
        self.e01 *= other;
    }
}

impl DivAssign<Scalar> for Scalar {
    fn div_assign(&mut self, other: Scalar) {
        self.s /= other.s;
    }
}

impl DivAssign<Vector> for Vector {
    fn div_assign(&mut self, other: Vector) {
        self.e0 /= other.e0;
        self.e1 /= other.e1;
    }
}

impl DivAssign<Bivector> for Bivector {
    fn div_assign(&mut self, other: Bivector) {
        self.e01 /= other.e01;
    }
}

impl DivAssign<Null> for Null {
    fn div_assign(&mut self, other: Null) {
    }
}

impl DivAssign<OddMultivector> for OddMultivector {
    fn div_assign(&mut self, other: OddMultivector) {
        self.e0 /= other.e0;
        self.e1 /= other.e1;
    }
}

impl DivAssign<EvenMultivector> for EvenMultivector {
    fn div_assign(&mut self, other: EvenMultivector) {
        self.s /= other.s;
        self.e01 /= other.e01;
    }
}

impl DivAssign<Multivector> for Multivector {
    fn div_assign(&mut self, other: Multivector) {
        self.s /= other.s;
        self.e0 /= other.e0;
        self.e1 /= other.e1;
        self.e01 /= other.e01;
    }
}

impl DivAssign<f32> for Scalar {
    fn div_assign(&mut self, other: f32) {
        self.s /= other;
    }
}

impl DivAssign<f32> for Vector {
    fn div_assign(&mut self, other: f32) {
        self.e0 /= other;
        self.e1 /= other;
    }
}

impl DivAssign<f32> for Bivector {
    fn div_assign(&mut self, other: f32) {
        self.e01 /= other;
    }
}

impl DivAssign<f32> for Null {
    fn div_assign(&mut self, other: f32) {
    }
}

impl DivAssign<f32> for OddMultivector {
    fn div_assign(&mut self, other: f32) {
        self.e0 /= other;
        self.e1 /= other;
    }
}

impl DivAssign<f32> for EvenMultivector {
    fn div_assign(&mut self, other: f32) {
        self.s /= other;
        self.e01 /= other;
    }
}

impl DivAssign<f32> for Multivector {
    fn div_assign(&mut self, other: f32) {
        self.s /= other;
        self.e0 /= other;
        self.e1 /= other;
        self.e01 /= other;
    }
}

impl Zero for Scalar {
    fn zero() -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl Zero for Vector {
    fn zero() -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Zero for Bivector {
    fn zero() -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl Zero for Null {
    fn zero() -> Null {
        Null
    }
}

impl Zero for OddMultivector {
    fn zero() -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Zero for EvenMultivector {
    fn zero() -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Zero for Multivector {
    fn zero() -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl One for Scalar {
    fn one() -> Scalar {
        Scalar {
            s: 1.0,
        }
    }
}

impl One for EvenMultivector {
    fn one() -> EvenMultivector {
        EvenMultivector {
            s: 1.0,
            e01: 0.0,
        }
    }
}

impl One for Multivector {
    fn one() -> Multivector {
        Multivector {
            s: 1.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl GradeInvolution for Scalar {
    type Output = Scalar;
    fn grade_involution(self) -> Scalar {
        Scalar {
            s: self.s,
        }
    }
}

impl GradeInvolution for Vector {
    type Output = Vector;
    fn grade_involution(self) -> Vector {
        Vector {
            e0: 0.0,
            e1: -self.e1,
        }
    }
}

impl GradeInvolution for Bivector {
    type Output = Bivector;
    fn grade_involution(self) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl GradeInvolution for Null {
    type Output = Null;
    fn grade_involution(self) -> Null {
        Null
    }
}

impl GradeInvolution for OddMultivector {
    type Output = OddMultivector;
    fn grade_involution(self) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: -self.e1,
        }
    }
}

impl GradeInvolution for EvenMultivector {
    type Output = EvenMultivector;
    fn grade_involution(self) -> EvenMultivector {
        EvenMultivector {
            s: self.s,
            e01: 0.0,
        }
    }
}

impl GradeInvolution for Multivector {
    type Output = Multivector;
    fn grade_involution(self) -> Multivector {
        Multivector {
            s: self.s,
            e0: 0.0,
            e1: -self.e1,
            e01: 0.0,
        }
    }
}

impl Reverse for Scalar {
    type Output = Scalar;
    fn reverse(self) -> Scalar {
        Scalar {
            s: self.s,
        }
    }
}

impl Reverse for Vector {
    type Output = Vector;
    fn reverse(self) -> Vector {
        Vector {
            e0: 0.0,
            e1: self.e1,
        }
    }
}

impl Reverse for Bivector {
    type Output = Bivector;
    fn reverse(self) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl Reverse for Null {
    type Output = Null;
    fn reverse(self) -> Null {
        Null
    }
}

impl Reverse for OddMultivector {
    type Output = OddMultivector;
    fn reverse(self) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e1,
        }
    }
}

impl Reverse for EvenMultivector {
    type Output = EvenMultivector;
    fn reverse(self) -> EvenMultivector {
        EvenMultivector {
            s: self.s,
            e01: 0.0,
        }
    }
}

impl Reverse for Multivector {
    type Output = Multivector;
    fn reverse(self) -> Multivector {
        Multivector {
            s: self.s,
            e0: 0.0,
            e1: self.e1,
            e01: 0.0,
        }
    }
}

impl Conjugate for Scalar {
    type Output = Scalar;
    fn conjugate(self) -> Scalar {
        Scalar {
            s: self.s,
        }
    }
}

impl Conjugate for Vector {
    type Output = Vector;
    fn conjugate(self) -> Vector {
        Vector {
            e0: 0.0,
            e1: -self.e1,
        }
    }
}

impl Conjugate for Bivector {
    type Output = Bivector;
    fn conjugate(self) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl Conjugate for Null {
    type Output = Null;
    fn conjugate(self) -> Null {
        Null
    }
}

impl Conjugate for OddMultivector {
    type Output = OddMultivector;
    fn conjugate(self) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: -self.e1,
        }
    }
}

impl Conjugate for EvenMultivector {
    type Output = EvenMultivector;
    fn conjugate(self) -> EvenMultivector {
        EvenMultivector {
            s: self.s,
            e01: 0.0,
        }
    }
}

impl Conjugate for Multivector {
    type Output = Multivector;
    fn conjugate(self) -> Multivector {
        Multivector {
            s: self.s,
            e0: 0.0,
            e1: -self.e1,
            e01: 0.0,
        }
    }
}

impl Dual for Scalar {
    type Output = Bivector;
    fn dual(self) -> Bivector {
        Bivector {
            e01: self.s,
        }
    }
}

impl Dual for Vector {
    type Output = Vector;
    fn dual(self) -> Vector {
        Vector {
            e0: self.e1,
            e1: 0.0,
        }
    }
}

impl Dual for Bivector {
    type Output = Scalar;
    fn dual(self) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl Dual for Null {
    type Output = Null;
    fn dual(self) -> Null {
        Null
    }
}

impl Dual for OddMultivector {
    type Output = OddMultivector;
    fn dual(self) -> OddMultivector {
        OddMultivector {
            e0: self.e1,
            e1: 0.0,
        }
    }
}

impl Dual for EvenMultivector {
    type Output = EvenMultivector;
    fn dual(self) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s,
        }
    }
}

impl Dual for Multivector {
    type Output = Multivector;
    fn dual(self) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e1,
            e1: 0.0,
            e01: self.s,
        }
    }
}

impl Undual for Scalar {
    type Output = Bivector;
    fn undual(self) -> Bivector {
        Bivector {
            e01: self.s,
        }
    }
}

impl Undual for Vector {
    type Output = Vector;
    fn undual(self) -> Vector {
        Vector {
            e0: -self.e1,
            e1: 0.0,
        }
    }
}

impl Undual for Bivector {
    type Output = Scalar;
    fn undual(self) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl Undual for Null {
    type Output = Null;
    fn undual(self) -> Null {
        Null
    }
}

impl Undual for OddMultivector {
    type Output = OddMultivector;
    fn undual(self) -> OddMultivector {
        OddMultivector {
            e0: -self.e1,
            e1: 0.0,
        }
    }
}

impl Undual for EvenMultivector {
    type Output = EvenMultivector;
    fn undual(self) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s,
        }
    }
}

impl Undual for Multivector {
    type Output = Multivector;
    fn undual(self) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1,
            e1: 0.0,
            e01: self.s,
        }
    }
}

impl NormSquared for Scalar {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        self.s * self.s
    }
}

impl NormSquared for Vector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        self.e1 * self.e1
    }
}

impl NormSquared for Bivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        0.0
    }
}

impl NormSquared for Null {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        0.0
    }
}

impl NormSquared for OddMultivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        self.e1 * self.e1
    }
}

impl NormSquared for EvenMultivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        self.s * self.s
    }
}

impl NormSquared for Multivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        self.s * self.s + self.e1 * self.e1
    }
}

impl Norm for Scalar {
    type Output = f32;
    fn norm(self) -> f32 {
        self.norm_squared().abs().sqrt()
    }
}

impl Norm for Vector {
    type Output = f32;
    fn norm(self) -> f32 {
        self.norm_squared().abs().sqrt()
    }
}

impl Norm for Bivector {
    type Output = f32;
    fn norm(self) -> f32 {
        self.norm_squared().abs().sqrt()
    }
}

impl Norm for Null {
    type Output = f32;
    fn norm(self) -> f32 {
        self.norm_squared().abs().sqrt()
    }
}

impl Norm for OddMultivector {
    type Output = f32;
    fn norm(self) -> f32 {
        self.norm_squared().abs().sqrt()
    }
}

impl Norm for EvenMultivector {
    type Output = f32;
    fn norm(self) -> f32 {
        self.norm_squared().abs().sqrt()
    }
}

impl Norm for Multivector {
    type Output = f32;
    fn norm(self) -> f32 {
        self.norm_squared().abs().sqrt()
    }
}

impl Inverse for Scalar {
    type Output = Scalar;
    fn inverse(self) -> Scalar {
        self.reverse().div(self.norm_squared())
    }
}

impl Inverse for Vector {
    type Output = Vector;
    fn inverse(self) -> Vector {
        self.reverse().div(self.norm_squared())
    }
}

impl Inverse for Bivector {
    type Output = Bivector;
    fn inverse(self) -> Bivector {
        self.reverse().div(self.norm_squared())
    }
}

impl Inverse for Null {
    type Output = Null;
    fn inverse(self) -> Null {
        self.reverse().div(self.norm_squared())
    }
}

impl Inverse for OddMultivector {
    type Output = OddMultivector;
    fn inverse(self) -> OddMultivector {
        self.reverse().div(self.norm_squared())
    }
}

impl Inverse for EvenMultivector {
    type Output = EvenMultivector;
    fn inverse(self) -> EvenMultivector {
        self.reverse().div(self.norm_squared())
    }
}

impl Inverse for Multivector {
    type Output = Multivector;
    fn inverse(self) -> Multivector {
        self.reverse().div(self.norm_squared())
    }
}

impl Normalized for Scalar {
    type Output = Scalar;
    fn normalized(self) -> Scalar {
        self.reverse().div(self.norm())
    }
}

impl Normalized for Vector {
    type Output = Vector;
    fn normalized(self) -> Vector {
        self.reverse().div(self.norm())
    }
}

impl Normalized for Bivector {
    type Output = Bivector;
    fn normalized(self) -> Bivector {
        self.reverse().div(self.norm())
    }
}

impl Normalized for Null {
    type Output = Null;
    fn normalized(self) -> Null {
        self.reverse().div(self.norm())
    }
}

impl Normalized for OddMultivector {
    type Output = OddMultivector;
    fn normalized(self) -> OddMultivector {
        self.reverse().div(self.norm())
    }
}

impl Normalized for EvenMultivector {
    type Output = EvenMultivector;
    fn normalized(self) -> EvenMultivector {
        self.reverse().div(self.norm())
    }
}

impl Normalized for Multivector {
    type Output = Multivector;
    fn normalized(self) -> Multivector {
        self.reverse().div(self.norm())
    }
}

impl Normalize for Scalar {
    fn normalize(&mut self) {
        self.reverse().div_assign(self.norm());
    }
}

impl Normalize for Vector {
    fn normalize(&mut self) {
        self.reverse().div_assign(self.norm());
    }
}

impl Normalize for Bivector {
    fn normalize(&mut self) {
        self.reverse().div_assign(self.norm());
    }
}

impl Normalize for Null {
    fn normalize(&mut self) {
        self.reverse().div_assign(self.norm());
    }
}

impl Normalize for OddMultivector {
    fn normalize(&mut self) {
        self.reverse().div_assign(self.norm());
    }
}

impl Normalize for EvenMultivector {
    fn normalize(&mut self) {
        self.reverse().div_assign(self.norm());
    }
}

impl Normalize for Multivector {
    fn normalize(&mut self) {
        self.reverse().div_assign(self.norm());
    }
}

impl GeometricProduct<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: 0.0,
        }
    }
}

impl GeometricProduct<Vector> for Scalar {
    type Output = OddMultivector;
    fn geometric_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl GeometricProduct<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl GeometricProduct<Null> for Scalar {
    type Output = Null;
    fn geometric_product(self, other: Null) -> Null {
        Null
    }
}

impl GeometricProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn geometric_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn geometric_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01,
        }
    }
}

impl GeometricProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn geometric_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01,
        }
    }
}

impl GeometricProduct<Scalar> for Vector {
    type Output = OddMultivector;
    fn geometric_product(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl GeometricProduct<Vector> for Vector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<Bivector> for Vector {
    type Output = OddMultivector;
    fn geometric_product(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl GeometricProduct<Null> for Vector {
    type Output = Null;
    fn geometric_product(self, other: Null) -> Null {
        Null
    }
}

impl GeometricProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn geometric_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
        }
    }
}

impl GeometricProduct<Multivector> for Vector {
    type Output = Multivector;
    fn geometric_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Vector> for Bivector {
    type Output = OddMultivector;
    fn geometric_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl GeometricProduct<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl GeometricProduct<Null> for Bivector {
    type Output = Null;
    fn geometric_product(self, other: Null) -> Null {
        Null
    }
}

impl GeometricProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn geometric_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn geometric_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Scalar> for Null {
    type Output = Null;
    fn geometric_product(self, other: Scalar) -> Null {
        Null
    }
}

impl GeometricProduct<Vector> for Null {
    type Output = Null;
    fn geometric_product(self, other: Vector) -> Null {
        Null
    }
}

impl GeometricProduct<Bivector> for Null {
    type Output = Null;
    fn geometric_product(self, other: Bivector) -> Null {
        Null
    }
}

impl GeometricProduct<Null> for Null {
    type Output = Null;
    fn geometric_product(self, other: Null) -> Null {
        Null
    }
}

impl GeometricProduct<OddMultivector> for Null {
    type Output = Null;
    fn geometric_product(self, other: OddMultivector) -> Null {
        Null
    }
}

impl GeometricProduct<EvenMultivector> for Null {
    type Output = Null;
    fn geometric_product(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl GeometricProduct<Multivector> for Null {
    type Output = Null;
    fn geometric_product(self, other: Multivector) -> Null {
        Null
    }
}

impl GeometricProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl GeometricProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl GeometricProduct<Null> for OddMultivector {
    type Output = Null;
    fn geometric_product(self, other: Null) -> Null {
        Null
    }
}

impl GeometricProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
        }
    }
}

impl GeometricProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn geometric_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
        }
    }
}

impl GeometricProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl GeometricProduct<Null> for EvenMultivector {
    type Output = Null;
    fn geometric_product(self, other: Null) -> Null {
        Null
    }
}

impl GeometricProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
        }
    }
}

impl GeometricProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn geometric_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Vector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, other: Vector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, other: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl GeometricProduct<Null> for Multivector {
    type Output = Null;
    fn geometric_product(self, other: Null) -> Null {
        Null
    }
}

impl GeometricProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl GeometricProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s + self.e1 * other.e1,
            e0: self.s * other.e0 + self.e0 * other.s - self.e1 * other.e01 + self.e01 * other.e1,
            e1: self.s * other.e1 + self.e1 * other.s,
            e01: self.s * other.e01 + self.e0 * other.e1 - self.e1 * other.e0 + self.e01 * other.s,
        }
    }
}

impl ScalarProduct<Scalar> for Scalar {
    type Output = f32;
    fn scalar_product(self, other: Scalar) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Vector> for Scalar {
    type Output = f32;
    fn scalar_product(self, other: Vector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Bivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, other: Bivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Null> for Scalar {
    type Output = f32;
    fn scalar_product(self, other: Null) -> f32 {
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, other: OddMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, other: EvenMultivector) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Multivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, other: Multivector) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Scalar> for Vector {
    type Output = f32;
    fn scalar_product(self, other: Scalar) -> f32 {
        0.0
    }
}

impl ScalarProduct<Vector> for Vector {
    type Output = f32;
    fn scalar_product(self, other: Vector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<Bivector> for Vector {
    type Output = f32;
    fn scalar_product(self, other: Bivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Null> for Vector {
    type Output = f32;
    fn scalar_product(self, other: Null) -> f32 {
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Vector {
    type Output = f32;
    fn scalar_product(self, other: OddMultivector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<EvenMultivector> for Vector {
    type Output = f32;
    fn scalar_product(self, other: EvenMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Multivector> for Vector {
    type Output = f32;
    fn scalar_product(self, other: Multivector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<Scalar> for Bivector {
    type Output = f32;
    fn scalar_product(self, other: Scalar) -> f32 {
        0.0
    }
}

impl ScalarProduct<Vector> for Bivector {
    type Output = f32;
    fn scalar_product(self, other: Vector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Bivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, other: Bivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Null> for Bivector {
    type Output = f32;
    fn scalar_product(self, other: Null) -> f32 {
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, other: OddMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, other: EvenMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Multivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, other: Multivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Scalar> for Null {
    type Output = f32;
    fn scalar_product(self, other: Scalar) -> f32 {
        0.0
    }
}

impl ScalarProduct<Vector> for Null {
    type Output = f32;
    fn scalar_product(self, other: Vector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Bivector> for Null {
    type Output = f32;
    fn scalar_product(self, other: Bivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Null> for Null {
    type Output = f32;
    fn scalar_product(self, other: Null) -> f32 {
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Null {
    type Output = f32;
    fn scalar_product(self, other: OddMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for Null {
    type Output = f32;
    fn scalar_product(self, other: EvenMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Multivector> for Null {
    type Output = f32;
    fn scalar_product(self, other: Multivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Scalar> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, other: Scalar) -> f32 {
        0.0
    }
}

impl ScalarProduct<Vector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, other: Vector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<Bivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, other: Bivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Null> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, other: Null) -> f32 {
        0.0
    }
}

impl ScalarProduct<OddMultivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, other: OddMultivector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<EvenMultivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, other: EvenMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Multivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, other: Multivector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<Scalar> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, other: Scalar) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Vector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, other: Vector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Bivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, other: Bivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Null> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, other: Null) -> f32 {
        0.0
    }
}

impl ScalarProduct<OddMultivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, other: OddMultivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, other: EvenMultivector) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Multivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, other: Multivector) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Scalar> for Multivector {
    type Output = f32;
    fn scalar_product(self, other: Scalar) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Vector> for Multivector {
    type Output = f32;
    fn scalar_product(self, other: Vector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<Bivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, other: Bivector) -> f32 {
        0.0
    }
}

impl ScalarProduct<Null> for Multivector {
    type Output = f32;
    fn scalar_product(self, other: Null) -> f32 {
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, other: OddMultivector) -> f32 {
        self.e1 * other.e1
    }
}

impl ScalarProduct<EvenMultivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, other: EvenMultivector) -> f32 {
        self.s * other.s
    }
}

impl ScalarProduct<Multivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, other: Multivector) -> f32 {
        self.s * other.s + self.e1 * other.e1
    }
}

impl LeftInnerProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn left_inner_product(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s * other.s,
        }
    }
}

impl LeftInnerProduct<Vector> for Scalar {
    type Output = Vector;
    fn left_inner_product(self, other: Vector) -> Vector {
        Vector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl LeftInnerProduct<Bivector> for Scalar {
    type Output = Bivector;
    fn left_inner_product(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Null> for Scalar {
    type Output = Null;
    fn left_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn left_inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn left_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Scalar> for Vector {
    type Output = Null;
    fn left_inner_product(self, other: Scalar) -> Null {
        Null
    }
}

impl LeftInnerProduct<Vector> for Vector {
    type Output = Scalar;
    fn left_inner_product(self, other: Vector) -> Scalar {
        Scalar {
            s: self.e1 * other.e1,
        }
    }
}

impl LeftInnerProduct<Bivector> for Vector {
    type Output = Vector;
    fn left_inner_product(self, other: Bivector) -> Vector {
        Vector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl LeftInnerProduct<Null> for Vector {
    type Output = Null;
    fn left_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn left_inner_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for Vector {
    type Output = Multivector;
    fn left_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Scalar> for Bivector {
    type Output = Null;
    fn left_inner_product(self, other: Scalar) -> Null {
        Null
    }
}

impl LeftInnerProduct<Vector> for Bivector {
    type Output = Null;
    fn left_inner_product(self, other: Vector) -> Null {
        Null
    }
}

impl LeftInnerProduct<Bivector> for Bivector {
    type Output = Scalar;
    fn left_inner_product(self, other: Bivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl LeftInnerProduct<Null> for Bivector {
    type Output = Null;
    fn left_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn left_inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn left_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Scalar> for Null {
    type Output = Null;
    fn left_inner_product(self, other: Scalar) -> Null {
        Null
    }
}

impl LeftInnerProduct<Vector> for Null {
    type Output = Null;
    fn left_inner_product(self, other: Vector) -> Null {
        Null
    }
}

impl LeftInnerProduct<Bivector> for Null {
    type Output = Null;
    fn left_inner_product(self, other: Bivector) -> Null {
        Null
    }
}

impl LeftInnerProduct<Null> for Null {
    type Output = Null;
    fn left_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Null {
    type Output = Null;
    fn left_inner_product(self, other: OddMultivector) -> Null {
        Null
    }
}

impl LeftInnerProduct<EvenMultivector> for Null {
    type Output = Null;
    fn left_inner_product(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl LeftInnerProduct<Multivector> for Null {
    type Output = Null;
    fn left_inner_product(self, other: Multivector) -> Null {
        Null
    }
}

impl LeftInnerProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl LeftInnerProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl LeftInnerProduct<Null> for OddMultivector {
    type Output = Null;
    fn left_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn left_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl LeftInnerProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Null> for EvenMultivector {
    type Output = Null;
    fn left_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn left_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Vector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, other: Vector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, other: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Null> for Multivector {
    type Output = Null;
    fn left_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: 0.0,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl LeftInnerProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s + self.e1 * other.e1,
            e0: self.s * other.e0 - self.e1 * other.e01,
            e1: self.s * other.e1,
            e01: self.s * other.e01,
        }
    }
}

impl RightInnerProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn right_inner_product(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s * other.s,
        }
    }
}

impl RightInnerProduct<Vector> for Scalar {
    type Output = Null;
    fn right_inner_product(self, other: Vector) -> Null {
        Null
    }
}

impl RightInnerProduct<Bivector> for Scalar {
    type Output = Null;
    fn right_inner_product(self, other: Bivector) -> Null {
        Null
    }
}

impl RightInnerProduct<Null> for Scalar {
    type Output = Null;
    fn right_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn right_inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn right_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Scalar> for Vector {
    type Output = Vector;
    fn right_inner_product(self, other: Scalar) -> Vector {
        Vector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl RightInnerProduct<Vector> for Vector {
    type Output = Scalar;
    fn right_inner_product(self, other: Vector) -> Scalar {
        Scalar {
            s: self.e1 * other.e1,
        }
    }
}

impl RightInnerProduct<Bivector> for Vector {
    type Output = Null;
    fn right_inner_product(self, other: Bivector) -> Null {
        Null
    }
}

impl RightInnerProduct<Null> for Vector {
    type Output = Null;
    fn right_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn right_inner_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl RightInnerProduct<Multivector> for Vector {
    type Output = Multivector;
    fn right_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Scalar> for Bivector {
    type Output = Bivector;
    fn right_inner_product(self, other: Scalar) -> Bivector {
        Bivector {
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Vector> for Bivector {
    type Output = Vector;
    fn right_inner_product(self, other: Vector) -> Vector {
        Vector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl RightInnerProduct<Bivector> for Bivector {
    type Output = Scalar;
    fn right_inner_product(self, other: Bivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl RightInnerProduct<Null> for Bivector {
    type Output = Null;
    fn right_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn right_inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn right_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Scalar> for Null {
    type Output = Null;
    fn right_inner_product(self, other: Scalar) -> Null {
        Null
    }
}

impl RightInnerProduct<Vector> for Null {
    type Output = Null;
    fn right_inner_product(self, other: Vector) -> Null {
        Null
    }
}

impl RightInnerProduct<Bivector> for Null {
    type Output = Null;
    fn right_inner_product(self, other: Bivector) -> Null {
        Null
    }
}

impl RightInnerProduct<Null> for Null {
    type Output = Null;
    fn right_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Null {
    type Output = Null;
    fn right_inner_product(self, other: OddMultivector) -> Null {
        Null
    }
}

impl RightInnerProduct<EvenMultivector> for Null {
    type Output = Null;
    fn right_inner_product(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl RightInnerProduct<Multivector> for Null {
    type Output = Null;
    fn right_inner_product(self, other: Multivector) -> Null {
        Null
    }
}

impl RightInnerProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl RightInnerProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl RightInnerProduct<Null> for OddMultivector {
    type Output = Null;
    fn right_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl RightInnerProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl RightInnerProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn right_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl RightInnerProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Null> for EvenMultivector {
    type Output = Null;
    fn right_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl RightInnerProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn right_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Vector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, other: Vector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, other: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<Null> for Multivector {
    type Output = Null;
    fn right_inner_product(self, other: Null) -> Null {
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl RightInnerProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s + self.e1 * other.e1,
            e0: self.e0 * other.s + self.e01 * other.e1,
            e1: self.e1 * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl InnerProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn inner_product(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s * other.s,
        }
    }
}

impl InnerProduct<Vector> for Scalar {
    type Output = Vector;
    fn inner_product(self, other: Vector) -> Vector {
        Vector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl InnerProduct<Bivector> for Scalar {
    type Output = Bivector;
    fn inner_product(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self.s * other.e01,
        }
    }
}

impl InnerProduct<Null> for Scalar {
    type Output = Null;
    fn inner_product(self, other: Null) -> Null {
        Null
    }
}

impl InnerProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl InnerProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01,
        }
    }
}

impl InnerProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01,
        }
    }
}

impl InnerProduct<Scalar> for Vector {
    type Output = Vector;
    fn inner_product(self, other: Scalar) -> Vector {
        Vector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl InnerProduct<Vector> for Vector {
    type Output = Scalar;
    fn inner_product(self, other: Vector) -> Scalar {
        Scalar {
            s: self.e1 * other.e1,
        }
    }
}

impl InnerProduct<Bivector> for Vector {
    type Output = Vector;
    fn inner_product(self, other: Bivector) -> Vector {
        Vector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl InnerProduct<Null> for Vector {
    type Output = Null;
    fn inner_product(self, other: Null) -> Null {
        Null
    }
}

impl InnerProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn inner_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl InnerProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn inner_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
        }
    }
}

impl InnerProduct<Multivector> for Vector {
    type Output = Multivector;
    fn inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
            e01: 0.0,
        }
    }
}

impl InnerProduct<Scalar> for Bivector {
    type Output = Bivector;
    fn inner_product(self, other: Scalar) -> Bivector {
        Bivector {
            e01: self.e01 * other.s,
        }
    }
}

impl InnerProduct<Vector> for Bivector {
    type Output = Vector;
    fn inner_product(self, other: Vector) -> Vector {
        Vector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl InnerProduct<Bivector> for Bivector {
    type Output = Scalar;
    fn inner_product(self, other: Bivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl InnerProduct<Null> for Bivector {
    type Output = Null;
    fn inner_product(self, other: Null) -> Null {
        Null
    }
}

impl InnerProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl InnerProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl InnerProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl InnerProduct<Scalar> for Null {
    type Output = Null;
    fn inner_product(self, other: Scalar) -> Null {
        Null
    }
}

impl InnerProduct<Vector> for Null {
    type Output = Null;
    fn inner_product(self, other: Vector) -> Null {
        Null
    }
}

impl InnerProduct<Bivector> for Null {
    type Output = Null;
    fn inner_product(self, other: Bivector) -> Null {
        Null
    }
}

impl InnerProduct<Null> for Null {
    type Output = Null;
    fn inner_product(self, other: Null) -> Null {
        Null
    }
}

impl InnerProduct<OddMultivector> for Null {
    type Output = Null;
    fn inner_product(self, other: OddMultivector) -> Null {
        Null
    }
}

impl InnerProduct<EvenMultivector> for Null {
    type Output = Null;
    fn inner_product(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl InnerProduct<Multivector> for Null {
    type Output = Null;
    fn inner_product(self, other: Multivector) -> Null {
        Null
    }
}

impl InnerProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn inner_product(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl InnerProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl InnerProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn inner_product(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl InnerProduct<Null> for OddMultivector {
    type Output = Null;
    fn inner_product(self, other: Null) -> Null {
        Null
    }
}

impl InnerProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl InnerProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn inner_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
        }
    }
}

impl InnerProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
            e01: 0.0,
        }
    }
}

impl InnerProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl InnerProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn inner_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
        }
    }
}

impl InnerProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl InnerProduct<Null> for EvenMultivector {
    type Output = Null;
    fn inner_product(self, other: Null) -> Null {
        Null
    }
}

impl InnerProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn inner_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
        }
    }
}

impl InnerProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl InnerProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl InnerProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn inner_product(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl InnerProduct<Vector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, other: Vector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
            e01: 0.0,
        }
    }
}

impl InnerProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, other: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl InnerProduct<Null> for Multivector {
    type Output = Null;
    fn inner_product(self, other: Null) -> Null {
        Null
    }
}

impl InnerProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0 + self.e01 * other.e1,
            e1: self.s * other.e1,
            e01: 0.0,
        }
    }
}

impl InnerProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s - self.e1 * other.e01,
            e1: self.e1 * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl InnerProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s + self.e1 * other.e1,
            e0: self.s * other.e0 + self.e0 * other.s - self.e1 * other.e01 + self.e01 * other.e1,
            e1: self.s * other.e1 + self.e1 * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl OuterProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn outer_product(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s * other.s,
        }
    }
}

impl OuterProduct<Vector> for Scalar {
    type Output = Vector;
    fn outer_product(self, other: Vector) -> Vector {
        Vector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl OuterProduct<Bivector> for Scalar {
    type Output = Bivector;
    fn outer_product(self, other: Bivector) -> Bivector {
        Bivector {
            e01: self.s * other.e01,
        }
    }
}

impl OuterProduct<Null> for Scalar {
    type Output = Null;
    fn outer_product(self, other: Null) -> Null {
        Null
    }
}

impl OuterProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn outer_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl OuterProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn outer_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01,
        }
    }
}

impl OuterProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn outer_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01,
        }
    }
}

impl OuterProduct<Scalar> for Vector {
    type Output = Vector;
    fn outer_product(self, other: Scalar) -> Vector {
        Vector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl OuterProduct<Vector> for Vector {
    type Output = Bivector;
    fn outer_product(self, other: Vector) -> Bivector {
        Bivector {
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<Bivector> for Vector {
    type Output = Null;
    fn outer_product(self, other: Bivector) -> Null {
        Null
    }
}

impl OuterProduct<Null> for Vector {
    type Output = Null;
    fn outer_product(self, other: Null) -> Null {
        Null
    }
}

impl OuterProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn outer_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn outer_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl OuterProduct<Multivector> for Vector {
    type Output = Multivector;
    fn outer_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<Scalar> for Bivector {
    type Output = Bivector;
    fn outer_product(self, other: Scalar) -> Bivector {
        Bivector {
            e01: self.e01 * other.s,
        }
    }
}

impl OuterProduct<Vector> for Bivector {
    type Output = Null;
    fn outer_product(self, other: Vector) -> Null {
        Null
    }
}

impl OuterProduct<Bivector> for Bivector {
    type Output = Null;
    fn outer_product(self, other: Bivector) -> Null {
        Null
    }
}

impl OuterProduct<Null> for Bivector {
    type Output = Null;
    fn outer_product(self, other: Null) -> Null {
        Null
    }
}

impl OuterProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn outer_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl OuterProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn outer_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl OuterProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn outer_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl OuterProduct<Scalar> for Null {
    type Output = Null;
    fn outer_product(self, other: Scalar) -> Null {
        Null
    }
}

impl OuterProduct<Vector> for Null {
    type Output = Null;
    fn outer_product(self, other: Vector) -> Null {
        Null
    }
}

impl OuterProduct<Bivector> for Null {
    type Output = Null;
    fn outer_product(self, other: Bivector) -> Null {
        Null
    }
}

impl OuterProduct<Null> for Null {
    type Output = Null;
    fn outer_product(self, other: Null) -> Null {
        Null
    }
}

impl OuterProduct<OddMultivector> for Null {
    type Output = Null;
    fn outer_product(self, other: OddMultivector) -> Null {
        Null
    }
}

impl OuterProduct<EvenMultivector> for Null {
    type Output = Null;
    fn outer_product(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl OuterProduct<Multivector> for Null {
    type Output = Null;
    fn outer_product(self, other: Multivector) -> Null {
        Null
    }
}

impl OuterProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn outer_product(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl OuterProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn outer_product(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl OuterProduct<Null> for OddMultivector {
    type Output = Null;
    fn outer_product(self, other: Null) -> Null {
        Null
    }
}

impl OuterProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn outer_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl OuterProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn outer_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl OuterProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn outer_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl OuterProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl OuterProduct<Null> for EvenMultivector {
    type Output = Null;
    fn outer_product(self, other: Null) -> Null {
        Null
    }
}

impl OuterProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn outer_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl OuterProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl OuterProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn outer_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl OuterProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn outer_product(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl OuterProduct<Vector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, other: Vector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, other: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl OuterProduct<Null> for Multivector {
    type Output = Null;
    fn outer_product(self, other: Null) -> Null {
        Null
    }
}

impl OuterProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl OuterProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl OuterProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0 + self.e0 * other.s,
            e1: self.s * other.e1 + self.e1 * other.s,
            e01: self.s * other.e01 + self.e0 * other.e1 - self.e1 * other.e0 + self.e01 * other.s,
        }
    }
}

impl RegressiveProduct<Scalar> for Scalar {
    type Output = Null;
    fn regressive_product(self, other: Scalar) -> Null {
        Null
    }
}

impl RegressiveProduct<Vector> for Scalar {
    type Output = Null;
    fn regressive_product(self, other: Vector) -> Null {
        Null
    }
}

impl RegressiveProduct<Bivector> for Scalar {
    type Output = Scalar;
    fn regressive_product(self, other: Bivector) -> Scalar {
        Scalar {
            s: self.s * other.e01,
        }
    }
}

impl RegressiveProduct<Null> for Scalar {
    type Output = Null;
    fn regressive_product(self, other: Null) -> Null {
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn regressive_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn regressive_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e01,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn regressive_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.e01,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Vector {
    type Output = Null;
    fn regressive_product(self, other: Scalar) -> Null {
        Null
    }
}

impl RegressiveProduct<Vector> for Vector {
    type Output = Scalar;
    fn regressive_product(self, other: Vector) -> Scalar {
        Scalar {
            s: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl RegressiveProduct<Bivector> for Vector {
    type Output = Vector;
    fn regressive_product(self, other: Bivector) -> Vector {
        Vector {
            e0: 0.0,
            e1: self.e1 * other.e01,
        }
    }
}

impl RegressiveProduct<Null> for Vector {
    type Output = Null;
    fn regressive_product(self, other: Null) -> Null {
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn regressive_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e0 * other.e1 - self.e1 * other.e0,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn regressive_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e1 * other.e01,
        }
    }
}

impl RegressiveProduct<Multivector> for Vector {
    type Output = Multivector;
    fn regressive_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e0 * other.e1 - self.e1 * other.e0,
            e0: 0.0,
            e1: self.e1 * other.e01,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Bivector {
    type Output = Scalar;
    fn regressive_product(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.e01 * other.s,
        }
    }
}

impl RegressiveProduct<Vector> for Bivector {
    type Output = Vector;
    fn regressive_product(self, other: Vector) -> Vector {
        Vector {
            e0: 0.0,
            e1: self.e01 * other.e1,
        }
    }
}

impl RegressiveProduct<Bivector> for Bivector {
    type Output = Bivector;
    fn regressive_product(self, other: Bivector) -> Bivector {
        Bivector {
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Null> for Bivector {
    type Output = Null;
    fn regressive_product(self, other: Null) -> Null {
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn regressive_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e01 * other.e1,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn regressive_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e01 * other.s,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn regressive_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e01 * other.s,
            e0: 0.0,
            e1: self.e01 * other.e1,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Null {
    type Output = Null;
    fn regressive_product(self, other: Scalar) -> Null {
        Null
    }
}

impl RegressiveProduct<Vector> for Null {
    type Output = Null;
    fn regressive_product(self, other: Vector) -> Null {
        Null
    }
}

impl RegressiveProduct<Bivector> for Null {
    type Output = Null;
    fn regressive_product(self, other: Bivector) -> Null {
        Null
    }
}

impl RegressiveProduct<Null> for Null {
    type Output = Null;
    fn regressive_product(self, other: Null) -> Null {
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Null {
    type Output = Null;
    fn regressive_product(self, other: OddMultivector) -> Null {
        Null
    }
}

impl RegressiveProduct<EvenMultivector> for Null {
    type Output = Null;
    fn regressive_product(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl RegressiveProduct<Multivector> for Null {
    type Output = Null;
    fn regressive_product(self, other: Multivector) -> Null {
        Null
    }
}

impl RegressiveProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl RegressiveProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e0 * other.e1 - self.e1 * other.e0,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e1 * other.e01,
        }
    }
}

impl RegressiveProduct<Null> for OddMultivector {
    type Output = Null;
    fn regressive_product(self, other: Null) -> Null {
        Null
    }
}

impl RegressiveProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e0 * other.e1 - self.e1 * other.e0,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e1 * other.e01,
        }
    }
}

impl RegressiveProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn regressive_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e0 * other.e1 - self.e1 * other.e0,
            e0: 0.0,
            e1: self.e1 * other.e01,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.e01 * other.s,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e01 * other.e1,
        }
    }
}

impl RegressiveProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e01,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Null> for EvenMultivector {
    type Output = Null;
    fn regressive_product(self, other: Null) -> Null {
        Null
    }
}

impl RegressiveProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e01 * other.e1,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e01 + self.e01 * other.s,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn regressive_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.e01 + self.e01 * other.s,
            e0: 0.0,
            e1: self.e01 * other.e1,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.e01 * other.s,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Vector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, other: Vector) -> Multivector {
        Multivector {
            s: self.e0 * other.e1 - self.e1 * other.e0,
            e0: 0.0,
            e1: self.e01 * other.e1,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, other: Bivector) -> Multivector {
        Multivector {
            s: self.s * other.e01,
            e0: 0.0,
            e1: self.e1 * other.e01,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Null> for Multivector {
    type Output = Null;
    fn regressive_product(self, other: Null) -> Null {
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.e0 * other.e1 - self.e1 * other.e0,
            e0: 0.0,
            e1: self.e01 * other.e1,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.e01 + self.e01 * other.s,
            e0: 0.0,
            e1: self.e1 * other.e01,
            e01: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.e01 + self.e0 * other.e1 - self.e1 * other.e0 + self.e01 * other.s,
            e0: 0.0,
            e1: self.e1 * other.e01 + self.e01 * other.e1,
            e01: 0.0,
        }
    }
}

impl Commutator<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn commutator(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Vector> for Scalar {
    type Output = OddMultivector;
    fn commutator(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Commutator<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn commutator(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Null> for Scalar {
    type Output = Null;
    fn commutator(self, other: Null) -> Null {
        Null
    }
}

impl Commutator<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn commutator(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn commutator(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Multivector> for Scalar {
    type Output = Multivector;
    fn commutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Scalar> for Vector {
    type Output = OddMultivector;
    fn commutator(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Commutator<Vector> for Vector {
    type Output = EvenMultivector;
    fn commutator(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<Bivector> for Vector {
    type Output = OddMultivector;
    fn commutator(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl Commutator<Null> for Vector {
    type Output = Null;
    fn commutator(self, other: Null) -> Null {
        Null
    }
}

impl Commutator<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn commutator(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn commutator(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl Commutator<Multivector> for Vector {
    type Output = Multivector;
    fn commutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn commutator(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Vector> for Bivector {
    type Output = OddMultivector;
    fn commutator(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl Commutator<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn commutator(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Null> for Bivector {
    type Output = Null;
    fn commutator(self, other: Null) -> Null {
        Null
    }
}

impl Commutator<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn commutator(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn commutator(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Multivector> for Bivector {
    type Output = Multivector;
    fn commutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Scalar> for Null {
    type Output = Null;
    fn commutator(self, other: Scalar) -> Null {
        Null
    }
}

impl Commutator<Vector> for Null {
    type Output = Null;
    fn commutator(self, other: Vector) -> Null {
        Null
    }
}

impl Commutator<Bivector> for Null {
    type Output = Null;
    fn commutator(self, other: Bivector) -> Null {
        Null
    }
}

impl Commutator<Null> for Null {
    type Output = Null;
    fn commutator(self, other: Null) -> Null {
        Null
    }
}

impl Commutator<OddMultivector> for Null {
    type Output = Null;
    fn commutator(self, other: OddMultivector) -> Null {
        Null
    }
}

impl Commutator<EvenMultivector> for Null {
    type Output = Null;
    fn commutator(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl Commutator<Multivector> for Null {
    type Output = Null;
    fn commutator(self, other: Multivector) -> Null {
        Null
    }
}

impl Commutator<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn commutator(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Commutator<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn commutator(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn commutator(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl Commutator<Null> for OddMultivector {
    type Output = Null;
    fn commutator(self, other: Null) -> Null {
        Null
    }
}

impl Commutator<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn commutator(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn commutator(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e1 * other.e01,
            e1: 0.0,
        }
    }
}

impl Commutator<Multivector> for OddMultivector {
    type Output = Multivector;
    fn commutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn commutator(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn commutator(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl Commutator<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn commutator(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Null> for EvenMultivector {
    type Output = Null;
    fn commutator(self, other: Null) -> Null {
        Null
    }
}

impl Commutator<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn commutator(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e01 * other.e1,
            e1: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn commutator(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn commutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Scalar> for Multivector {
    type Output = Multivector;
    fn commutator(self, other: Scalar) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Vector> for Multivector {
    type Output = Multivector;
    fn commutator(self, other: Vector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<Bivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, other: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Null> for Multivector {
    type Output = Null;
    fn commutator(self, other: Null) -> Null {
        Null
    }
}

impl Commutator<OddMultivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: self.e01 * other.e1,
            e1: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Commutator<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Commutator<Multivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: -self.e1 * other.e01 + self.e01 * other.e1,
            e1: 0.0,
            e01: self.e0 * other.e1 - self.e1 * other.e0,
        }
    }
}

impl Anticommutator<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: 0.0,
        }
    }
}

impl Anticommutator<Vector> for Scalar {
    type Output = OddMultivector;
    fn anticommutator(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl Anticommutator<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl Anticommutator<Null> for Scalar {
    type Output = Null;
    fn anticommutator(self, other: Null) -> Null {
        Null
    }
}

impl Anticommutator<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn anticommutator(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl Anticommutator<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn anticommutator(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01,
        }
    }
}

impl Anticommutator<Multivector> for Scalar {
    type Output = Multivector;
    fn anticommutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01,
        }
    }
}

impl Anticommutator<Scalar> for Vector {
    type Output = OddMultivector;
    fn anticommutator(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl Anticommutator<Vector> for Vector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Anticommutator<Bivector> for Vector {
    type Output = OddMultivector;
    fn anticommutator(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Anticommutator<Null> for Vector {
    type Output = Null;
    fn anticommutator(self, other: Null) -> Null {
        Null
    }
}

impl Anticommutator<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Anticommutator<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn anticommutator(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl Anticommutator<Multivector> for Vector {
    type Output = Multivector;
    fn anticommutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: 0.0,
        }
    }
}

impl Anticommutator<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl Anticommutator<Vector> for Bivector {
    type Output = OddMultivector;
    fn anticommutator(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Anticommutator<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Anticommutator<Null> for Bivector {
    type Output = Null;
    fn anticommutator(self, other: Null) -> Null {
        Null
    }
}

impl Anticommutator<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn anticommutator(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Anticommutator<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl Anticommutator<Multivector> for Bivector {
    type Output = Multivector;
    fn anticommutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: self.e01 * other.s,
        }
    }
}

impl Anticommutator<Scalar> for Null {
    type Output = Null;
    fn anticommutator(self, other: Scalar) -> Null {
        Null
    }
}

impl Anticommutator<Vector> for Null {
    type Output = Null;
    fn anticommutator(self, other: Vector) -> Null {
        Null
    }
}

impl Anticommutator<Bivector> for Null {
    type Output = Null;
    fn anticommutator(self, other: Bivector) -> Null {
        Null
    }
}

impl Anticommutator<Null> for Null {
    type Output = Null;
    fn anticommutator(self, other: Null) -> Null {
        Null
    }
}

impl Anticommutator<OddMultivector> for Null {
    type Output = Null;
    fn anticommutator(self, other: OddMultivector) -> Null {
        Null
    }
}

impl Anticommutator<EvenMultivector> for Null {
    type Output = Null;
    fn anticommutator(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl Anticommutator<Multivector> for Null {
    type Output = Null;
    fn anticommutator(self, other: Multivector) -> Null {
        Null
    }
}

impl Anticommutator<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl Anticommutator<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Anticommutator<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Anticommutator<Null> for OddMultivector {
    type Output = Null;
    fn anticommutator(self, other: Null) -> Null {
        Null
    }
}

impl Anticommutator<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Anticommutator<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
        }
    }
}

impl Anticommutator<Multivector> for OddMultivector {
    type Output = Multivector;
    fn anticommutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: 0.0,
        }
    }
}

impl Anticommutator<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl Anticommutator<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl Anticommutator<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl Anticommutator<Null> for EvenMultivector {
    type Output = Null;
    fn anticommutator(self, other: Null) -> Null {
        Null
    }
}

impl Anticommutator<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.s * other.e0,
            e1: self.s * other.e1,
        }
    }
}

impl Anticommutator<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl Anticommutator<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn anticommutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl Anticommutator<Scalar> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.e01 * other.s,
        }
    }
}

impl Anticommutator<Vector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, other: Vector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: 0.0,
        }
    }
}

impl Anticommutator<Bivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, other: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: self.s * other.e01,
        }
    }
}

impl Anticommutator<Null> for Multivector {
    type Output = Null;
    fn anticommutator(self, other: Null) -> Null {
        Null
    }
}

impl Anticommutator<OddMultivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.e1 * other.e1,
            e0: self.s * other.e0,
            e1: self.s * other.e1,
            e01: 0.0,
        }
    }
}

impl Anticommutator<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s,
            e0: self.e0 * other.s,
            e1: self.e1 * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl Anticommutator<Multivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s + self.e1 * other.e1,
            e0: self.s * other.e0 + self.e0 * other.s,
            e1: self.s * other.e1 + self.e1 * other.s,
            e01: self.s * other.e01 + self.e01 * other.s,
        }
    }
}

impl Transform<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn transform(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s,
            e01: 0.0,
        }
    }
}

impl Transform<Vector> for Scalar {
    type Output = EvenMultivector;
    fn transform(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Transform<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn transform(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Transform<Null> for Scalar {
    type Output = Null;
    fn transform(self, other: Null) -> Null {
        Null
    }
}

impl Transform<OddMultivector> for Scalar {
    type Output = EvenMultivector;
    fn transform(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Transform<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn transform(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Transform<Multivector> for Scalar {
    type Output = Multivector;
    fn transform(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01,
            e0: 2.0 * self.s * other.s * other.e0 + 2.0 * self.s * other.e1 * other.e01,
            e1: 2.0 * self.s * other.s * other.e1 - 2.0 * self.s * other.e0 * other.e01,
            e01: 0.0,
        }
    }
}

impl Transform<Scalar> for Vector {
    type Output = OddMultivector;
    fn transform(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
        }
    }
}

impl Transform<Vector> for Vector {
    type Output = OddMultivector;
    fn transform(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: -self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: 2.0 * self.e0 * other.e0 * other.e1 - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1,
        }
    }
}

impl Transform<Bivector> for Vector {
    type Output = OddMultivector;
    fn transform(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: -self.e1 * other.e01 * other.e01,
        }
    }
}

impl Transform<Null> for Vector {
    type Output = Null;
    fn transform(self, other: Null) -> Null {
        Null
    }
}

impl Transform<OddMultivector> for Vector {
    type Output = OddMultivector;
    fn transform(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: 2.0 * self.e0 * other.e0 * other.e1 - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1,
        }
    }
}

impl Transform<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn transform(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s + 2.0 * self.e1 * other.s * other.e01,
            e1: -2.0 * self.e0 * other.s * other.e01 + self.e1 * other.s * other.s - self.e1 * other.e01 * other.e01,
        }
    }
}

impl Transform<Multivector> for Vector {
    type Output = Multivector;
    fn transform(self, other: Multivector) -> Multivector {
        Multivector {
            s: 2.0 * self.e0 * other.s * other.e0 - 2.0 * self.e0 * other.e1 * other.e01 + 2.0 * self.e1 * other.s * other.e1 + 2.0 * self.e1 * other.e0 * other.e01,
            e0: self.e0 * other.s * other.s - self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.s * other.e01 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: -2.0 * self.e0 * other.s * other.e01 + 2.0 * self.e0 * other.e0 * other.e1 + self.e1 * other.s * other.s - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1 - self.e1 * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Transform<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn transform(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Transform<Vector> for Bivector {
    type Output = EvenMultivector;
    fn transform(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: -self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn transform(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Transform<Null> for Bivector {
    type Output = Null;
    fn transform(self, other: Null) -> Null {
        Null
    }
}

impl Transform<OddMultivector> for Bivector {
    type Output = EvenMultivector;
    fn transform(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: -self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn transform(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Transform<Multivector> for Bivector {
    type Output = Multivector;
    fn transform(self, other: Multivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: self.e01 * other.s * other.s - self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<Scalar> for Null {
    type Output = Null;
    fn transform(self, other: Scalar) -> Null {
        Null
    }
}

impl Transform<Vector> for Null {
    type Output = Null;
    fn transform(self, other: Vector) -> Null {
        Null
    }
}

impl Transform<Bivector> for Null {
    type Output = Null;
    fn transform(self, other: Bivector) -> Null {
        Null
    }
}

impl Transform<Null> for Null {
    type Output = Null;
    fn transform(self, other: Null) -> Null {
        Null
    }
}

impl Transform<OddMultivector> for Null {
    type Output = Null;
    fn transform(self, other: OddMultivector) -> Null {
        Null
    }
}

impl Transform<EvenMultivector> for Null {
    type Output = Null;
    fn transform(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl Transform<Multivector> for Null {
    type Output = Null;
    fn transform(self, other: Multivector) -> Null {
        Null
    }
}

impl Transform<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
        }
    }
}

impl Transform<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: -self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: 2.0 * self.e0 * other.e0 * other.e1 - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1,
        }
    }
}

impl Transform<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: -self.e1 * other.e01 * other.e01,
        }
    }
}

impl Transform<Null> for OddMultivector {
    type Output = Null;
    fn transform(self, other: Null) -> Null {
        Null
    }
}

impl Transform<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: -self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: 2.0 * self.e0 * other.e0 * other.e1 - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1,
        }
    }
}

impl Transform<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s + 2.0 * self.e1 * other.s * other.e01,
            e1: -2.0 * self.e0 * other.s * other.e01 + self.e1 * other.s * other.s - self.e1 * other.e01 * other.e01,
        }
    }
}

impl Transform<Multivector> for OddMultivector {
    type Output = Multivector;
    fn transform(self, other: Multivector) -> Multivector {
        Multivector {
            s: 2.0 * self.e0 * other.s * other.e0 - 2.0 * self.e0 * other.e1 * other.e01 + 2.0 * self.e1 * other.s * other.e1 + 2.0 * self.e1 * other.e0 * other.e01,
            e0: self.e0 * other.s * other.s - self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.s * other.e01 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: -2.0 * self.e0 * other.s * other.e01 + 2.0 * self.e0 * other.e0 * other.e1 + self.e1 * other.s * other.s - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1 - self.e1 * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Transform<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Transform<Vector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: -self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Transform<Null> for EvenMultivector {
    type Output = Null;
    fn transform(self, other: Null) -> Null {
        Null
    }
}

impl Transform<OddMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: -self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Transform<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn transform(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01,
            e0: 2.0 * self.s * other.s * other.e0 + 2.0 * self.s * other.e1 * other.e01,
            e1: 2.0 * self.s * other.s * other.e1 - 2.0 * self.s * other.e0 * other.e01,
            e01: self.e01 * other.s * other.s - self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<Scalar> for Multivector {
    type Output = Multivector;
    fn transform(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s,
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Transform<Vector> for Multivector {
    type Output = Multivector;
    fn transform(self, other: Vector) -> Multivector {
        Multivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e0: -self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: 2.0 * self.e0 * other.e0 * other.e1 - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1,
            e01: -self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<Bivector> for Multivector {
    type Output = Multivector;
    fn transform(self, other: Bivector) -> Multivector {
        Multivector {
            s: self.s * other.e01 * other.e01,
            e0: 0.0,
            e1: -self.e1 * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Transform<Null> for Multivector {
    type Output = Null;
    fn transform(self, other: Null) -> Null {
        Null
    }
}

impl Transform<OddMultivector> for Multivector {
    type Output = Multivector;
    fn transform(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e0: -self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: 2.0 * self.e0 * other.e0 * other.e1 - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1,
            e01: -self.e01 * other.e1 * other.e1,
        }
    }
}

impl Transform<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn transform(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01,
            e0: self.e0 * other.s * other.s + 2.0 * self.e1 * other.s * other.e01,
            e1: -2.0 * self.e0 * other.s * other.e01 + self.e1 * other.s * other.s - self.e1 * other.e01 * other.e01,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Transform<Multivector> for Multivector {
    type Output = Multivector;
    fn transform(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01 + 2.0 * self.e0 * other.s * other.e0 - 2.0 * self.e0 * other.e1 * other.e01 + 2.0 * self.e1 * other.s * other.e1 + 2.0 * self.e1 * other.e0 * other.e01,
            e0: 2.0 * self.s * other.s * other.e0 + 2.0 * self.s * other.e1 * other.e01 + self.e0 * other.s * other.s - self.e0 * other.e1 * other.e1 + 2.0 * self.e1 * other.s * other.e01 + 2.0 * self.e1 * other.e0 * other.e1,
            e1: 2.0 * self.s * other.s * other.e1 - 2.0 * self.s * other.e0 * other.e01 - 2.0 * self.e0 * other.s * other.e01 + 2.0 * self.e0 * other.e0 * other.e1 + self.e1 * other.s * other.s - self.e1 * other.e0 * other.e0 + self.e1 * other.e1 * other.e1 - self.e1 * other.e01 * other.e01,
            e01: self.e01 * other.s * other.s - self.e01 * other.e1 * other.e1,
        }
    }
}

impl Project<Scalar> for Scalar {
    type Output = Null;
    fn project(self, other: Scalar) -> Null {
        Null
    }
}

impl Project<Vector> for Scalar {
    type Output = Scalar;
    fn project(self, other: Vector) -> Scalar {
        Scalar {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
        }
    }
}

impl Project<Bivector> for Scalar {
    type Output = Scalar;
    fn project(self, other: Bivector) -> Scalar {
        Scalar {
            s: self.s * other.e01 * other.e01,
        }
    }
}

impl Project<Null> for Scalar {
    type Output = EvenMultivector;
    fn project(self, other: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Project<OddMultivector> for Scalar {
    type Output = EvenMultivector;
    fn project(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Project<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn project(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01,
            e01: -self.s * other.s * other.e01,
        }
    }
}

impl Project<Multivector> for Scalar {
    type Output = EvenMultivector;
    fn project(self, other: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01,
            e01: -self.s * other.s * other.e01,
        }
    }
}

impl Project<Scalar> for Vector {
    type Output = Null;
    fn project(self, other: Scalar) -> Null {
        Null
    }
}

impl Project<Vector> for Vector {
    type Output = Null;
    fn project(self, other: Vector) -> Null {
        Null
    }
}

impl Project<Bivector> for Vector {
    type Output = Vector;
    fn project(self, other: Bivector) -> Vector {
        Vector {
            e0: 0.0,
            e1: self.e1 * other.e01 * other.e01,
        }
    }
}

impl Project<Null> for Vector {
    type Output = OddMultivector;
    fn project(self, other: Null) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Project<OddMultivector> for Vector {
    type Output = OddMultivector;
    fn project(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e1 * other.e0 * other.e1,
            e1: self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1,
        }
    }
}

impl Project<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn project(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e1 * other.e01 * other.e01,
        }
    }
}

impl Project<Multivector> for Vector {
    type Output = OddMultivector;
    fn project(self, other: Multivector) -> OddMultivector {
        OddMultivector {
            e0: self.e1 * other.e0 * other.e1,
            e1: self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1 + self.e1 * other.e01 * other.e01,
        }
    }
}

impl Project<Scalar> for Bivector {
    type Output = Null;
    fn project(self, other: Scalar) -> Null {
        Null
    }
}

impl Project<Vector> for Bivector {
    type Output = Null;
    fn project(self, other: Vector) -> Null {
        Null
    }
}

impl Project<Bivector> for Bivector {
    type Output = Null;
    fn project(self, other: Bivector) -> Null {
        Null
    }
}

impl Project<Null> for Bivector {
    type Output = EvenMultivector;
    fn project(self, other: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Project<OddMultivector> for Bivector {
    type Output = EvenMultivector;
    fn project(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Project<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn project(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: -self.e01 * other.s * other.e01,
            e01: 0.0,
        }
    }
}

impl Project<Multivector> for Bivector {
    type Output = EvenMultivector;
    fn project(self, other: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: -self.e01 * other.s * other.e01,
            e01: 0.0,
        }
    }
}

impl Project<Scalar> for Null {
    type Output = Null;
    fn project(self, other: Scalar) -> Null {
        Null
    }
}

impl Project<Vector> for Null {
    type Output = Null;
    fn project(self, other: Vector) -> Null {
        Null
    }
}

impl Project<Bivector> for Null {
    type Output = Null;
    fn project(self, other: Bivector) -> Null {
        Null
    }
}

impl Project<Null> for Null {
    type Output = Null;
    fn project(self, other: Null) -> Null {
        Null
    }
}

impl Project<OddMultivector> for Null {
    type Output = Null;
    fn project(self, other: OddMultivector) -> Null {
        Null
    }
}

impl Project<EvenMultivector> for Null {
    type Output = Null;
    fn project(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl Project<Multivector> for Null {
    type Output = Null;
    fn project(self, other: Multivector) -> Null {
        Null
    }
}

impl Project<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Project<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.e1 * other.e0 * other.e1,
            e1: self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1,
        }
    }
}

impl Project<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e1 * other.e01 * other.e01,
        }
    }
}

impl Project<Null> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, other: Null) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Project<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e1 * other.e0 * other.e1,
            e1: self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1,
        }
    }
}

impl Project<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: self.e1 * other.e01 * other.e01,
        }
    }
}

impl Project<Multivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, other: Multivector) -> OddMultivector {
        OddMultivector {
            e0: self.e1 * other.e0 * other.e1,
            e1: self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1 + self.e1 * other.e01 * other.e01,
        }
    }
}

impl Project<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s,
            e01: 0.0,
        }
    }
}

impl Project<Vector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Project<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Project<Null> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, other: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Project<OddMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Project<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01 - self.e01 * other.s * other.e01,
            e01: -self.s * other.s * other.e01,
        }
    }
}

impl Project<Multivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, other: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01 - self.e01 * other.s * other.e01,
            e01: -self.s * other.s * other.e01,
        }
    }
}

impl Project<Scalar> for Multivector {
    type Output = Multivector;
    fn project(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Project<Vector> for Multivector {
    type Output = Multivector;
    fn project(self, other: Vector) -> Multivector {
        Multivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e0: self.e1 * other.e0 * other.e1,
            e1: self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Project<Bivector> for Multivector {
    type Output = Multivector;
    fn project(self, other: Bivector) -> Multivector {
        Multivector {
            s: self.s * other.e01 * other.e01,
            e0: 0.0,
            e1: self.e1 * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Project<Null> for Multivector {
    type Output = Multivector;
    fn project(self, other: Null) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Project<OddMultivector> for Multivector {
    type Output = Multivector;
    fn project(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e0: self.e1 * other.e0 * other.e1,
            e1: self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Project<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn project(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01 - self.e01 * other.s * other.e01,
            e0: 0.0,
            e1: self.e1 * other.e01 * other.e01,
            e01: -self.s * other.s * other.e01,
        }
    }
}

impl Project<Multivector> for Multivector {
    type Output = Multivector;
    fn project(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01 + self.e0 * other.s * other.e0 + self.e0 * other.e1 * other.e01 + self.e1 * other.s * other.e1 - self.e1 * other.e0 * other.e01 - self.e01 * other.s * other.e01,
            e0: self.s * other.s * other.e0 + self.s * other.e1 * other.e01 + self.e1 * other.e0 * other.e1,
            e1: self.s * other.s * other.e1 - self.s * other.e0 * other.e01 + self.e0 * other.e0 * other.e1 + self.e1 * other.e1 * other.e1 + self.e1 * other.e01 * other.e01 - self.e01 * other.e1 * other.e01,
            e01: -self.s * other.s * other.e01 - self.e1 * other.e1 * other.e01,
        }
    }
}

impl Reject<Scalar> for Scalar {
    type Output = Scalar;
    fn reject(self, other: Scalar) -> Scalar {
        Scalar {
            s: self.s * other.s * other.s,
        }
    }
}

impl Reject<Vector> for Scalar {
    type Output = Scalar;
    fn reject(self, other: Vector) -> Scalar {
        Scalar {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
        }
    }
}

impl Reject<Bivector> for Scalar {
    type Output = Scalar;
    fn reject(self, other: Bivector) -> Scalar {
        Scalar {
            s: self.s * other.e01 * other.e01,
        }
    }
}

impl Reject<Null> for Scalar {
    type Output = EvenMultivector;
    fn reject(self, other: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Scalar {
    type Output = EvenMultivector;
    fn reject(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Reject<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn reject(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01,
            e01: self.s * other.s * other.e01,
        }
    }
}

impl Reject<Multivector> for Scalar {
    type Output = EvenMultivector;
    fn reject(self, other: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01,
            e01: self.s * other.s * other.e01,
        }
    }
}

impl Reject<Scalar> for Vector {
    type Output = Vector;
    fn reject(self, other: Scalar) -> Vector {
        Vector {
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
        }
    }
}

impl Reject<Vector> for Vector {
    type Output = Vector;
    fn reject(self, other: Vector) -> Vector {
        Vector {
            e0: self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.e0 * other.e0,
        }
    }
}

impl Reject<Bivector> for Vector {
    type Output = Null;
    fn reject(self, other: Bivector) -> Null {
        Null
    }
}

impl Reject<Null> for Vector {
    type Output = OddMultivector;
    fn reject(self, other: Null) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Vector {
    type Output = OddMultivector;
    fn reject(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.e0 * other.e0,
        }
    }
}

impl Reject<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn reject(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
        }
    }
}

impl Reject<Multivector> for Vector {
    type Output = OddMultivector;
    fn reject(self, other: Multivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s + self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.s * other.s + self.e1 * other.e0 * other.e0,
        }
    }
}

impl Reject<Scalar> for Bivector {
    type Output = Bivector;
    fn reject(self, other: Scalar) -> Bivector {
        Bivector {
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Vector> for Bivector {
    type Output = Null;
    fn reject(self, other: Vector) -> Null {
        Null
    }
}

impl Reject<Bivector> for Bivector {
    type Output = Null;
    fn reject(self, other: Bivector) -> Null {
        Null
    }
}

impl Reject<Null> for Bivector {
    type Output = EvenMultivector;
    fn reject(self, other: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Bivector {
    type Output = EvenMultivector;
    fn reject(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Reject<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn reject(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e01 * other.s * other.e01,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Multivector> for Bivector {
    type Output = EvenMultivector;
    fn reject(self, other: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: self.e01 * other.s * other.e01,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Scalar> for Null {
    type Output = Null;
    fn reject(self, other: Scalar) -> Null {
        Null
    }
}

impl Reject<Vector> for Null {
    type Output = Null;
    fn reject(self, other: Vector) -> Null {
        Null
    }
}

impl Reject<Bivector> for Null {
    type Output = Null;
    fn reject(self, other: Bivector) -> Null {
        Null
    }
}

impl Reject<Null> for Null {
    type Output = Null;
    fn reject(self, other: Null) -> Null {
        Null
    }
}

impl Reject<OddMultivector> for Null {
    type Output = Null;
    fn reject(self, other: OddMultivector) -> Null {
        Null
    }
}

impl Reject<EvenMultivector> for Null {
    type Output = Null;
    fn reject(self, other: EvenMultivector) -> Null {
        Null
    }
}

impl Reject<Multivector> for Null {
    type Output = Null;
    fn reject(self, other: Multivector) -> Null {
        Null
    }
}

impl Reject<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, other: Scalar) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
        }
    }
}

impl Reject<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, other: Vector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.e0 * other.e0,
        }
    }
}

impl Reject<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, other: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Reject<Null> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, other: Null) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
        }
    }
}

impl Reject<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, other: OddMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.e0 * other.e0,
        }
    }
}

impl Reject<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, other: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
        }
    }
}

impl Reject<Multivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, other: Multivector) -> OddMultivector {
        OddMultivector {
            e0: self.e0 * other.s * other.s + self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.s * other.s + self.e1 * other.e0 * other.e0,
        }
    }
}

impl Reject<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, other: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Vector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, other: Vector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Reject<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, other: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e01 * other.e01,
            e01: 0.0,
        }
    }
}

impl Reject<Null> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, other: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
        }
    }
}

impl Reject<OddMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, other: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e01: 0.0,
        }
    }
}

impl Reject<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, other: EvenMultivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01 + self.e01 * other.s * other.e01,
            e01: self.s * other.s * other.e01 + self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Multivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, other: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01 + self.e01 * other.s * other.e01,
            e01: self.s * other.s * other.e01 + self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Scalar> for Multivector {
    type Output = Multivector;
    fn reject(self, other: Scalar) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s,
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
            e01: self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Vector> for Multivector {
    type Output = Multivector;
    fn reject(self, other: Vector) -> Multivector {
        Multivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e0: self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.e0 * other.e0,
            e01: 0.0,
        }
    }
}

impl Reject<Bivector> for Multivector {
    type Output = Multivector;
    fn reject(self, other: Bivector) -> Multivector {
        Multivector {
            s: self.s * other.e01 * other.e01,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Reject<Null> for Multivector {
    type Output = Multivector;
    fn reject(self, other: Null) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e01: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Multivector {
    type Output = Multivector;
    fn reject(self, other: OddMultivector) -> Multivector {
        Multivector {
            s: self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1,
            e0: self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1,
            e1: -self.e0 * other.e0 * other.e1 + self.e1 * other.e0 * other.e0,
            e01: 0.0,
        }
    }
}

impl Reject<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn reject(self, other: EvenMultivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e01 * other.e01 + self.e01 * other.s * other.e01,
            e0: self.e0 * other.s * other.s,
            e1: self.e1 * other.s * other.s,
            e01: self.s * other.s * other.e01 + self.e01 * other.s * other.s,
        }
    }
}

impl Reject<Multivector> for Multivector {
    type Output = Multivector;
    fn reject(self, other: Multivector) -> Multivector {
        Multivector {
            s: self.s * other.s * other.s + self.s * other.e0 * other.e0 + self.s * other.e1 * other.e1 + self.s * other.e01 * other.e01 + self.e0 * other.s * other.e0 + self.e0 * other.e1 * other.e01 + self.e1 * other.s * other.e1 - self.e1 * other.e0 * other.e01 + self.e01 * other.s * other.e01,
            e0: self.s * other.s * other.e0 + self.s * other.e1 * other.e01 + self.e0 * other.s * other.s + self.e0 * other.e1 * other.e1 - self.e1 * other.e0 * other.e1 + self.e01 * other.s * other.e1,
            e1: self.s * other.s * other.e1 - self.s * other.e0 * other.e01 - self.e0 * other.e0 * other.e1 + self.e1 * other.s * other.s + self.e1 * other.e0 * other.e0 - self.e01 * other.s * other.e0,
            e01: self.s * other.s * other.e01 + self.e0 * other.s * other.e1 - self.e1 * other.s * other.e0 + self.e01 * other.s * other.s,
        }
    }
}
