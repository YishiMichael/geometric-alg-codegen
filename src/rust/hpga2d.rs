// Automatically generated by `geometric-alg-codegen`

#![allow(unused_variables)]

use crate::traits::*;

#[derive(Clone, Copy, Debug, Default)]
pub struct Scalar {
    pub s: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Vector {
    pub e0: f32,
    pub e1: f32,
    pub e2: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Bivector {
    pub e01: f32,
    pub e20: f32,
    pub e12: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Trivector {
    pub e012: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Null;

#[derive(Clone, Copy, Debug, Default)]
pub struct OddMultivector {
    pub e0: f32,
    pub e1: f32,
    pub e2: f32,
    pub e012: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct EvenMultivector {
    pub s: f32,
    pub e01: f32,
    pub e20: f32,
    pub e12: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Multivector {
    pub s: f32,
    pub e0: f32,
    pub e1: f32,
    pub e2: f32,
    pub e01: f32,
    pub e20: f32,
    pub e12: f32,
    pub e012: f32,
}

impl From<Scalar> for f32 {
    fn from(a: Scalar) -> f32 {
        a.s
    }
}

impl From<Vector> for f32 {
    fn from(a: Vector) -> f32 {
        0.0
    }
}

impl From<Bivector> for f32 {
    fn from(a: Bivector) -> f32 {
        0.0
    }
}

impl From<Trivector> for f32 {
    fn from(a: Trivector) -> f32 {
        0.0
    }
}

impl From<Null> for f32 {
    fn from(a: Null) -> f32 {
        0.0
    }
}

impl From<OddMultivector> for f32 {
    fn from(a: OddMultivector) -> f32 {
        0.0
    }
}

impl From<EvenMultivector> for f32 {
    fn from(a: EvenMultivector) -> f32 {
        a.s
    }
}

impl From<Multivector> for f32 {
    fn from(a: Multivector) -> f32 {
        a.s
    }
}

impl From<f32> for Scalar {
    fn from(a: f32) -> Scalar {
        Scalar {
            s: a,
        }
    }
}

impl From<Vector> for Scalar {
    fn from(a: Vector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<Bivector> for Scalar {
    fn from(a: Bivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<Trivector> for Scalar {
    fn from(a: Trivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<Null> for Scalar {
    fn from(a: Null) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<OddMultivector> for Scalar {
    fn from(a: OddMultivector) -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl From<EvenMultivector> for Scalar {
    fn from(a: EvenMultivector) -> Scalar {
        Scalar {
            s: a.s,
        }
    }
}

impl From<Multivector> for Scalar {
    fn from(a: Multivector) -> Scalar {
        Scalar {
            s: a.s,
        }
    }
}

impl From<f32> for Vector {
    fn from(a: f32) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl From<Scalar> for Vector {
    fn from(a: Scalar) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl From<Bivector> for Vector {
    fn from(a: Bivector) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl From<Trivector> for Vector {
    fn from(a: Trivector) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl From<Null> for Vector {
    fn from(a: Null) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl From<OddMultivector> for Vector {
    fn from(a: OddMultivector) -> Vector {
        Vector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
        }
    }
}

impl From<EvenMultivector> for Vector {
    fn from(a: EvenMultivector) -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl From<Multivector> for Vector {
    fn from(a: Multivector) -> Vector {
        Vector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
        }
    }
}

impl From<f32> for Bivector {
    fn from(a: f32) -> Bivector {
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Scalar> for Bivector {
    fn from(a: Scalar) -> Bivector {
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Vector> for Bivector {
    fn from(a: Vector) -> Bivector {
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Trivector> for Bivector {
    fn from(a: Trivector) -> Bivector {
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Null> for Bivector {
    fn from(a: Null) -> Bivector {
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<OddMultivector> for Bivector {
    fn from(a: OddMultivector) -> Bivector {
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<EvenMultivector> for Bivector {
    fn from(a: EvenMultivector) -> Bivector {
        Bivector {
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl From<Multivector> for Bivector {
    fn from(a: Multivector) -> Bivector {
        Bivector {
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl From<f32> for Trivector {
    fn from(a: f32) -> Trivector {
        Trivector {
            e012: 0.0,
        }
    }
}

impl From<Scalar> for Trivector {
    fn from(a: Scalar) -> Trivector {
        Trivector {
            e012: 0.0,
        }
    }
}

impl From<Vector> for Trivector {
    fn from(a: Vector) -> Trivector {
        Trivector {
            e012: 0.0,
        }
    }
}

impl From<Bivector> for Trivector {
    fn from(a: Bivector) -> Trivector {
        Trivector {
            e012: 0.0,
        }
    }
}

impl From<Null> for Trivector {
    fn from(a: Null) -> Trivector {
        Trivector {
            e012: 0.0,
        }
    }
}

impl From<OddMultivector> for Trivector {
    fn from(a: OddMultivector) -> Trivector {
        Trivector {
            e012: a.e012,
        }
    }
}

impl From<EvenMultivector> for Trivector {
    fn from(a: EvenMultivector) -> Trivector {
        Trivector {
            e012: 0.0,
        }
    }
}

impl From<Multivector> for Trivector {
    fn from(a: Multivector) -> Trivector {
        Trivector {
            e012: a.e012,
        }
    }
}

impl From<f32> for Null {
    fn from(a: f32) -> Null {
        Null
    }
}

impl From<Scalar> for Null {
    fn from(a: Scalar) -> Null {
        Null
    }
}

impl From<Vector> for Null {
    fn from(a: Vector) -> Null {
        Null
    }
}

impl From<Bivector> for Null {
    fn from(a: Bivector) -> Null {
        Null
    }
}

impl From<Trivector> for Null {
    fn from(a: Trivector) -> Null {
        Null
    }
}

impl From<OddMultivector> for Null {
    fn from(a: OddMultivector) -> Null {
        Null
    }
}

impl From<EvenMultivector> for Null {
    fn from(a: EvenMultivector) -> Null {
        Null
    }
}

impl From<Multivector> for Null {
    fn from(a: Multivector) -> Null {
        Null
    }
}

impl From<f32> for OddMultivector {
    fn from(a: f32) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl From<Scalar> for OddMultivector {
    fn from(a: Scalar) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl From<Vector> for OddMultivector {
    fn from(a: Vector) -> OddMultivector {
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: 0.0,
        }
    }
}

impl From<Bivector> for OddMultivector {
    fn from(a: Bivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl From<Trivector> for OddMultivector {
    fn from(a: Trivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e012,
        }
    }
}

impl From<Null> for OddMultivector {
    fn from(a: Null) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl From<EvenMultivector> for OddMultivector {
    fn from(a: EvenMultivector) -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl From<Multivector> for OddMultivector {
    fn from(a: Multivector) -> OddMultivector {
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: a.e012,
        }
    }
}

impl From<f32> for EvenMultivector {
    fn from(a: f32) -> EvenMultivector {
        EvenMultivector {
            s: a,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Scalar> for EvenMultivector {
    fn from(a: Scalar) -> EvenMultivector {
        EvenMultivector {
            s: a.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Vector> for EvenMultivector {
    fn from(a: Vector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Bivector> for EvenMultivector {
    fn from(a: Bivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl From<Trivector> for EvenMultivector {
    fn from(a: Trivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Null> for EvenMultivector {
    fn from(a: Null) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<OddMultivector> for EvenMultivector {
    fn from(a: OddMultivector) -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl From<Multivector> for EvenMultivector {
    fn from(a: Multivector) -> EvenMultivector {
        EvenMultivector {
            s: a.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl From<f32> for Multivector {
    fn from(a: f32) -> Multivector {
        Multivector {
            s: a,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl From<Scalar> for Multivector {
    fn from(a: Scalar) -> Multivector {
        Multivector {
            s: a.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl From<Vector> for Multivector {
    fn from(a: Vector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl From<Bivector> for Multivector {
    fn from(a: Bivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: 0.0,
        }
    }
}

impl From<Trivector> for Multivector {
    fn from(a: Trivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl From<Null> for Multivector {
    fn from(a: Null) -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl From<OddMultivector> for Multivector {
    fn from(a: OddMultivector) -> Multivector {
        Multivector {
            s: 0.0,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl From<EvenMultivector> for Multivector {
    fn from(a: EvenMultivector) -> Multivector {
        Multivector {
            s: a.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: 0.0,
        }
    }
}

impl Neg for Scalar {
    type Output = Scalar;
    fn neg(self) -> Scalar {
        let a = self;
        Scalar {
            s: -a.s,
        }
    }
}

impl Neg for Vector {
    type Output = Vector;
    fn neg(self) -> Vector {
        let a = self;
        Vector {
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
        }
    }
}

impl Neg for Bivector {
    type Output = Bivector;
    fn neg(self) -> Bivector {
        let a = self;
        Bivector {
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
        }
    }
}

impl Neg for Trivector {
    type Output = Trivector;
    fn neg(self) -> Trivector {
        let a = self;
        Trivector {
            e012: -a.e012,
        }
    }
}

impl Neg for Null {
    type Output = Null;
    fn neg(self) -> Null {
        let a = self;
        Null
    }
}

impl Neg for OddMultivector {
    type Output = OddMultivector;
    fn neg(self) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
            e012: -a.e012,
        }
    }
}

impl Neg for EvenMultivector {
    type Output = EvenMultivector;
    fn neg(self) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.s,
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
        }
    }
}

impl Neg for Multivector {
    type Output = Multivector;
    fn neg(self) -> Multivector {
        let a = self;
        Multivector {
            s: -a.s,
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
            e012: -a.e012,
        }
    }
}

impl Add<Scalar> for f32 {
    type Output = Scalar;
    fn add(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a + b.s,
        }
    }
}

impl Add<Vector> for f32 {
    type Output = Multivector;
    fn add(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Add<Bivector> for f32 {
    type Output = EvenMultivector;
    fn add(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
        }
    }
}

impl Add<Trivector> for f32 {
    type Output = Multivector;
    fn add(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: b.e012,
        }
    }
}

impl Add<Null> for f32 {
    type Output = EvenMultivector;
    fn add(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Add<OddMultivector> for f32 {
    type Output = Multivector;
    fn add(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: b.e012,
        }
    }
}

impl Add<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn add(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a + b.s,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
        }
    }
}

impl Add<Multivector> for f32 {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a + b.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: b.e012,
        }
    }
}

impl Add<f32> for Scalar {
    type Output = Scalar;
    fn add(self, b: f32) -> Scalar {
        let a = self;
        Scalar {
            s: a.s + b,
        }
    }
}

impl Add<Scalar> for Scalar {
    type Output = Scalar;
    fn add(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s + b.s,
        }
    }
}

impl Add<Vector> for Scalar {
    type Output = Multivector;
    fn add(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Add<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn add(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
        }
    }
}

impl Add<Trivector> for Scalar {
    type Output = Multivector;
    fn add(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: b.e012,
        }
    }
}

impl Add<Null> for Scalar {
    type Output = EvenMultivector;
    fn add(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Add<OddMultivector> for Scalar {
    type Output = Multivector;
    fn add(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: b.e012,
        }
    }
}

impl Add<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn add(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s + b.s,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
        }
    }
}

impl Add<Multivector> for Scalar {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s + b.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: b.e012,
        }
    }
}

impl Add<f32> for Vector {
    type Output = Multivector;
    fn add(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: b,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Add<Scalar> for Vector {
    type Output = Multivector;
    fn add(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Add<Vector> for Vector {
    type Output = Vector;
    fn add(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
        }
    }
}

impl Add<Bivector> for Vector {
    type Output = Multivector;
    fn add(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: 0.0,
        }
    }
}

impl Add<Trivector> for Vector {
    type Output = OddMultivector;
    fn add(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: b.e012,
        }
    }
}

impl Add<Null> for Vector {
    type Output = OddMultivector;
    fn add(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: 0.0,
        }
    }
}

impl Add<OddMultivector> for Vector {
    type Output = OddMultivector;
    fn add(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e012: b.e012,
        }
    }
}

impl Add<EvenMultivector> for Vector {
    type Output = Multivector;
    fn add(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: 0.0,
        }
    }
}

impl Add<Multivector> for Vector {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: b.e012,
        }
    }
}

impl Add<f32> for Bivector {
    type Output = EvenMultivector;
    fn add(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: b,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Add<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn add(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: b.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Add<Vector> for Bivector {
    type Output = Multivector;
    fn add(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: 0.0,
        }
    }
}

impl Add<Bivector> for Bivector {
    type Output = Bivector;
    fn add(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
        }
    }
}

impl Add<Trivector> for Bivector {
    type Output = Multivector;
    fn add(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: b.e012,
        }
    }
}

impl Add<Null> for Bivector {
    type Output = EvenMultivector;
    fn add(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Add<OddMultivector> for Bivector {
    type Output = Multivector;
    fn add(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: b.e012,
        }
    }
}

impl Add<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn add(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: b.s,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
        }
    }
}

impl Add<Multivector> for Bivector {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
            e012: b.e012,
        }
    }
}

impl Add<f32> for Trivector {
    type Output = Multivector;
    fn add(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: b,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Add<Scalar> for Trivector {
    type Output = Multivector;
    fn add(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Add<Vector> for Trivector {
    type Output = OddMultivector;
    fn add(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e012: a.e012,
        }
    }
}

impl Add<Bivector> for Trivector {
    type Output = Multivector;
    fn add(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: a.e012,
        }
    }
}

impl Add<Trivector> for Trivector {
    type Output = Trivector;
    fn add(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<Null> for Trivector {
    type Output = OddMultivector;
    fn add(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e012,
        }
    }
}

impl Add<OddMultivector> for Trivector {
    type Output = OddMultivector;
    fn add(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<EvenMultivector> for Trivector {
    type Output = Multivector;
    fn add(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: a.e012,
        }
    }
}

impl Add<Multivector> for Trivector {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<f32> for Null {
    type Output = EvenMultivector;
    fn add(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: b,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Add<Scalar> for Null {
    type Output = EvenMultivector;
    fn add(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Add<Vector> for Null {
    type Output = OddMultivector;
    fn add(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e012: 0.0,
        }
    }
}

impl Add<Bivector> for Null {
    type Output = EvenMultivector;
    fn add(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
        }
    }
}

impl Add<Trivector> for Null {
    type Output = OddMultivector;
    fn add(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: b.e012,
        }
    }
}

impl Add<Null> for Null {
    type Output = Null;
    fn add(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Add<OddMultivector> for Null {
    type Output = OddMultivector;
    fn add(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e012: b.e012,
        }
    }
}

impl Add<EvenMultivector> for Null {
    type Output = EvenMultivector;
    fn add(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: b.s,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
        }
    }
}

impl Add<Multivector> for Null {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: b.e012,
        }
    }
}

impl Add<f32> for OddMultivector {
    type Output = Multivector;
    fn add(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: b,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Add<Scalar> for OddMultivector {
    type Output = Multivector;
    fn add(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Add<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn add(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e012: a.e012,
        }
    }
}

impl Add<Bivector> for OddMultivector {
    type Output = Multivector;
    fn add(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: a.e012,
        }
    }
}

impl Add<Trivector> for OddMultivector {
    type Output = OddMultivector;
    fn add(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<Null> for OddMultivector {
    type Output = OddMultivector;
    fn add(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: a.e012,
        }
    }
}

impl Add<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn add(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<EvenMultivector> for OddMultivector {
    type Output = Multivector;
    fn add(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: a.e012,
        }
    }
}

impl Add<Multivector> for OddMultivector {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: b.s,
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e01: b.e01,
            e20: b.e20,
            e12: b.e12,
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn add(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s + b,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Add<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn add(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s + b.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Add<Vector> for EvenMultivector {
    type Output = Multivector;
    fn add(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: 0.0,
        }
    }
}

impl Add<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn add(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
        }
    }
}

impl Add<Trivector> for EvenMultivector {
    type Output = Multivector;
    fn add(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: b.e012,
        }
    }
}

impl Add<Null> for EvenMultivector {
    type Output = EvenMultivector;
    fn add(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Add<OddMultivector> for EvenMultivector {
    type Output = Multivector;
    fn add(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: b.e012,
        }
    }
}

impl Add<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn add(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s + b.s,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
        }
    }
}

impl Add<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s + b.s,
            e0: b.e0,
            e1: b.e1,
            e2: b.e2,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
            e012: b.e012,
        }
    }
}

impl Add<f32> for Multivector {
    type Output = Multivector;
    fn add(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: a.s + b,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Add<Scalar> for Multivector {
    type Output = Multivector;
    fn add(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s + b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Add<Vector> for Multivector {
    type Output = Multivector;
    fn add(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Add<Bivector> for Multivector {
    type Output = Multivector;
    fn add(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
            e012: a.e012,
        }
    }
}

impl Add<Trivector> for Multivector {
    type Output = Multivector;
    fn add(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<Null> for Multivector {
    type Output = Multivector;
    fn add(self, b: Null) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Add<OddMultivector> for Multivector {
    type Output = Multivector;
    fn add(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012 + b.e012,
        }
    }
}

impl Add<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn add(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s + b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
            e012: a.e012,
        }
    }
}

impl Add<Multivector> for Multivector {
    type Output = Multivector;
    fn add(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s + b.s,
            e0: a.e0 + b.e0,
            e1: a.e1 + b.e1,
            e2: a.e2 + b.e2,
            e01: a.e01 + b.e01,
            e20: a.e20 + b.e20,
            e12: a.e12 + b.e12,
            e012: a.e012 + b.e012,
        }
    }
}

impl Sub<Scalar> for f32 {
    type Output = Scalar;
    fn sub(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a - b.s,
        }
    }
}

impl Sub<Vector> for f32 {
    type Output = Multivector;
    fn sub(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Sub<Bivector> for f32 {
    type Output = EvenMultivector;
    fn sub(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
        }
    }
}

impl Sub<Trivector> for f32 {
    type Output = Multivector;
    fn sub(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: -b.e012,
        }
    }
}

impl Sub<Null> for f32 {
    type Output = EvenMultivector;
    fn sub(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Sub<OddMultivector> for f32 {
    type Output = Multivector;
    fn sub(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: -b.e012,
        }
    }
}

impl Sub<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn sub(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a - b.s,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
        }
    }
}

impl Sub<Multivector> for f32 {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a - b.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<f32> for Scalar {
    type Output = Scalar;
    fn sub(self, b: f32) -> Scalar {
        let a = self;
        Scalar {
            s: a.s - b,
        }
    }
}

impl Sub<Scalar> for Scalar {
    type Output = Scalar;
    fn sub(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s - b.s,
        }
    }
}

impl Sub<Vector> for Scalar {
    type Output = Multivector;
    fn sub(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Sub<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn sub(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
        }
    }
}

impl Sub<Trivector> for Scalar {
    type Output = Multivector;
    fn sub(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: -b.e012,
        }
    }
}

impl Sub<Null> for Scalar {
    type Output = EvenMultivector;
    fn sub(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Sub<OddMultivector> for Scalar {
    type Output = Multivector;
    fn sub(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: -b.e012,
        }
    }
}

impl Sub<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn sub(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s - b.s,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
        }
    }
}

impl Sub<Multivector> for Scalar {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s - b.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<f32> for Vector {
    type Output = Multivector;
    fn sub(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: -b,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Sub<Scalar> for Vector {
    type Output = Multivector;
    fn sub(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Sub<Vector> for Vector {
    type Output = Vector;
    fn sub(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
        }
    }
}

impl Sub<Bivector> for Vector {
    type Output = Multivector;
    fn sub(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: 0.0,
        }
    }
}

impl Sub<Trivector> for Vector {
    type Output = OddMultivector;
    fn sub(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: -b.e012,
        }
    }
}

impl Sub<Null> for Vector {
    type Output = OddMultivector;
    fn sub(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: 0.0,
        }
    }
}

impl Sub<OddMultivector> for Vector {
    type Output = OddMultivector;
    fn sub(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e012: -b.e012,
        }
    }
}

impl Sub<EvenMultivector> for Vector {
    type Output = Multivector;
    fn sub(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: 0.0,
        }
    }
}

impl Sub<Multivector> for Vector {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<f32> for Bivector {
    type Output = EvenMultivector;
    fn sub(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -b,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Sub<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn sub(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -b.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Sub<Vector> for Bivector {
    type Output = Multivector;
    fn sub(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: 0.0,
        }
    }
}

impl Sub<Bivector> for Bivector {
    type Output = Bivector;
    fn sub(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
        }
    }
}

impl Sub<Trivector> for Bivector {
    type Output = Multivector;
    fn sub(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<Null> for Bivector {
    type Output = EvenMultivector;
    fn sub(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Sub<OddMultivector> for Bivector {
    type Output = Multivector;
    fn sub(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn sub(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -b.s,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
        }
    }
}

impl Sub<Multivector> for Bivector {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<f32> for Trivector {
    type Output = Multivector;
    fn sub(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: -b,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Sub<Scalar> for Trivector {
    type Output = Multivector;
    fn sub(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Sub<Vector> for Trivector {
    type Output = OddMultivector;
    fn sub(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e012: a.e012,
        }
    }
}

impl Sub<Bivector> for Trivector {
    type Output = Multivector;
    fn sub(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Trivector> for Trivector {
    type Output = Trivector;
    fn sub(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<Null> for Trivector {
    type Output = OddMultivector;
    fn sub(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e012,
        }
    }
}

impl Sub<OddMultivector> for Trivector {
    type Output = OddMultivector;
    fn sub(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<EvenMultivector> for Trivector {
    type Output = Multivector;
    fn sub(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Multivector> for Trivector {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<f32> for Null {
    type Output = EvenMultivector;
    fn sub(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -b,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Sub<Scalar> for Null {
    type Output = EvenMultivector;
    fn sub(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Sub<Vector> for Null {
    type Output = OddMultivector;
    fn sub(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e012: 0.0,
        }
    }
}

impl Sub<Bivector> for Null {
    type Output = EvenMultivector;
    fn sub(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
        }
    }
}

impl Sub<Trivector> for Null {
    type Output = OddMultivector;
    fn sub(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: -b.e012,
        }
    }
}

impl Sub<Null> for Null {
    type Output = Null;
    fn sub(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Sub<OddMultivector> for Null {
    type Output = OddMultivector;
    fn sub(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e012: -b.e012,
        }
    }
}

impl Sub<EvenMultivector> for Null {
    type Output = EvenMultivector;
    fn sub(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -b.s,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
        }
    }
}

impl Sub<Multivector> for Null {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<f32> for OddMultivector {
    type Output = Multivector;
    fn sub(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: -b,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Sub<Scalar> for OddMultivector {
    type Output = Multivector;
    fn sub(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012,
        }
    }
}

impl Sub<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn sub(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e012: a.e012,
        }
    }
}

impl Sub<Bivector> for OddMultivector {
    type Output = Multivector;
    fn sub(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Trivector> for OddMultivector {
    type Output = OddMultivector;
    fn sub(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<Null> for OddMultivector {
    type Output = OddMultivector;
    fn sub(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: a.e012,
        }
    }
}

impl Sub<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn sub(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<EvenMultivector> for OddMultivector {
    type Output = Multivector;
    fn sub(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Multivector> for OddMultivector {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -b.s,
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e01: -b.e01,
            e20: -b.e20,
            e12: -b.e12,
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn sub(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s - b,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Sub<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn sub(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s - b.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Sub<Vector> for EvenMultivector {
    type Output = Multivector;
    fn sub(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: 0.0,
        }
    }
}

impl Sub<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn sub(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
        }
    }
}

impl Sub<Trivector> for EvenMultivector {
    type Output = Multivector;
    fn sub(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<Null> for EvenMultivector {
    type Output = EvenMultivector;
    fn sub(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Sub<OddMultivector> for EvenMultivector {
    type Output = Multivector;
    fn sub(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn sub(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s - b.s,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
        }
    }
}

impl Sub<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s - b.s,
            e0: -b.e0,
            e1: -b.e1,
            e2: -b.e2,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
            e012: -b.e012,
        }
    }
}

impl Sub<f32> for Multivector {
    type Output = Multivector;
    fn sub(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: a.s - b,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Scalar> for Multivector {
    type Output = Multivector;
    fn sub(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s - b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Vector> for Multivector {
    type Output = Multivector;
    fn sub(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Bivector> for Multivector {
    type Output = Multivector;
    fn sub(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Trivector> for Multivector {
    type Output = Multivector;
    fn sub(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<Null> for Multivector {
    type Output = Multivector;
    fn sub(self, b: Null) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012,
        }
    }
}

impl Sub<OddMultivector> for Multivector {
    type Output = Multivector;
    fn sub(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: a.e012 - b.e012,
        }
    }
}

impl Sub<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn sub(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s - b.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
            e012: a.e012,
        }
    }
}

impl Sub<Multivector> for Multivector {
    type Output = Multivector;
    fn sub(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s - b.s,
            e0: a.e0 - b.e0,
            e1: a.e1 - b.e1,
            e2: a.e2 - b.e2,
            e01: a.e01 - b.e01,
            e20: a.e20 - b.e20,
            e12: a.e12 - b.e12,
            e012: a.e012 - b.e012,
        }
    }
}

impl Mul<Scalar> for f32 {
    type Output = Scalar;
    fn mul(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a * b.s,
        }
    }
}

impl Mul<Vector> for f32 {
    type Output = Vector;
    fn mul(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a * b.e0,
            e1: a * b.e1,
            e2: a * b.e2,
        }
    }
}

impl Mul<Bivector> for f32 {
    type Output = Bivector;
    fn mul(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a * b.e01,
            e20: a * b.e20,
            e12: a * b.e12,
        }
    }
}

impl Mul<Trivector> for f32 {
    type Output = Trivector;
    fn mul(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a * b.e012,
        }
    }
}

impl Mul<Null> for f32 {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Mul<OddMultivector> for f32 {
    type Output = OddMultivector;
    fn mul(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a * b.e0,
            e1: a * b.e1,
            e2: a * b.e2,
            e012: a * b.e012,
        }
    }
}

impl Mul<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn mul(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a * b.s,
            e01: a * b.e01,
            e20: a * b.e20,
            e12: a * b.e12,
        }
    }
}

impl Mul<Multivector> for f32 {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a * b.s,
            e0: a * b.e0,
            e1: a * b.e1,
            e2: a * b.e2,
            e01: a * b.e01,
            e20: a * b.e20,
            e12: a * b.e12,
            e012: a * b.e012,
        }
    }
}

impl Mul<f32> for Scalar {
    type Output = Scalar;
    fn mul(self, b: f32) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b,
        }
    }
}

impl Mul<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn mul(self, b: Scalar) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for Scalar {
    type Output = OddMultivector;
    fn mul(self, b: Vector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn mul(self, b: Bivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for Scalar {
    type Output = OddMultivector;
    fn mul(self, b: Trivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for Scalar {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn mul(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn mul(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for Scalar {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<f32> for Vector {
    type Output = Vector;
    fn mul(self, b: f32) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b,
            e1: a.e1 * b,
            e2: a.e2 * b,
        }
    }
}

impl Mul<Scalar> for Vector {
    type Output = OddMultivector;
    fn mul(self, b: Scalar) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for Vector {
    type Output = EvenMultivector;
    fn mul(self, b: Vector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for Vector {
    type Output = OddMultivector;
    fn mul(self, b: Bivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for Vector {
    type Output = EvenMultivector;
    fn mul(self, b: Trivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for Vector {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn mul(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn mul(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for Vector {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<f32> for Bivector {
    type Output = Bivector;
    fn mul(self, b: f32) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b,
            e20: a.e20 * b,
            e12: a.e12 * b,
        }
    }
}

impl Mul<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn mul(self, b: Scalar) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for Bivector {
    type Output = OddMultivector;
    fn mul(self, b: Vector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn mul(self, b: Bivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for Bivector {
    type Output = OddMultivector;
    fn mul(self, b: Trivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for Bivector {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn mul(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn mul(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for Bivector {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<f32> for Trivector {
    type Output = Trivector;
    fn mul(self, b: f32) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b,
        }
    }
}

impl Mul<Scalar> for Trivector {
    type Output = OddMultivector;
    fn mul(self, b: Scalar) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for Trivector {
    type Output = EvenMultivector;
    fn mul(self, b: Vector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for Trivector {
    type Output = OddMultivector;
    fn mul(self, b: Bivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for Trivector {
    type Output = EvenMultivector;
    fn mul(self, b: Trivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for Trivector {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn mul(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn mul(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for Trivector {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<f32> for Null {
    type Output = Null;
    fn mul(self, b: f32) -> Null {
        let a = self;
        Null
    }
}

impl Mul<Scalar> for Null {
    type Output = Null;
    fn mul(self, b: Scalar) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for Null {
    type Output = Null;
    fn mul(self, b: Vector) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for Null {
    type Output = Null;
    fn mul(self, b: Bivector) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for Null {
    type Output = Null;
    fn mul(self, b: Trivector) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for Null {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for Null {
    type Output = Null;
    fn mul(self, b: OddMultivector) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for Null {
    type Output = Null;
    fn mul(self, b: EvenMultivector) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for Null {
    type Output = Null;
    fn mul(self, b: Multivector) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<f32> for OddMultivector {
    type Output = OddMultivector;
    fn mul(self, b: f32) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b,
            e1: a.e1 * b,
            e2: a.e2 * b,
            e012: a.e012 * b,
        }
    }
}

impl Mul<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn mul(self, b: Scalar) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn mul(self, b: Vector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn mul(self, b: Bivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn mul(self, b: Trivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for OddMultivector {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn mul(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn mul(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for OddMultivector {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn mul(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b,
            e01: a.e01 * b,
            e20: a.e20 * b,
            e12: a.e12 * b,
        }
    }
}

impl Mul<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn mul(self, b: Scalar) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn mul(self, b: Vector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn mul(self, b: Bivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn mul(self, b: Trivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for EvenMultivector {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn mul(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn mul(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<f32> for Multivector {
    type Output = Multivector;
    fn mul(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b,
            e0: a.e0 * b,
            e1: a.e1 * b,
            e2: a.e2 * b,
            e01: a.e01 * b,
            e20: a.e20 * b,
            e12: a.e12 * b,
            e012: a.e012 * b,
        }
    }
}

impl Mul<Scalar> for Multivector {
    type Output = Multivector;
    fn mul(self, b: Scalar) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Vector> for Multivector {
    type Output = Multivector;
    fn mul(self, b: Vector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Bivector> for Multivector {
    type Output = Multivector;
    fn mul(self, b: Bivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Trivector> for Multivector {
    type Output = Multivector;
    fn mul(self, b: Trivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Null> for Multivector {
    type Output = Null;
    fn mul(self, b: Null) -> Null {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<OddMultivector> for Multivector {
    type Output = Multivector;
    fn mul(self, b: OddMultivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn mul(self, b: EvenMultivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Mul<Multivector> for Multivector {
    type Output = Multivector;
    fn mul(self, b: Multivector) -> Multivector {
        let a = self;
        a.geometric_product(b)
    }
}

impl Div<Scalar> for f32 {
    type Output = EvenMultivector;
    fn div(self, b: Scalar) -> EvenMultivector {
        let a = self;
        a.mul(b.inverse())
    }
}

impl Div<Vector> for f32 {
    type Output = OddMultivector;
    fn div(self, b: Vector) -> OddMultivector {
        let a = self;
        a.mul(b.inverse())
    }
}

impl Div<Bivector> for f32 {
    type Output = EvenMultivector;
    fn div(self, b: Bivector) -> EvenMultivector {
        let a = self;
        a.mul(b.inverse())
    }
}

impl Div<Trivector> for f32 {
    type Output = OddMultivector;
    fn div(self, b: Trivector) -> OddMultivector {
        let a = self;
        a.mul(b.inverse())
    }
}

impl Div<OddMultivector> for f32 {
    type Output = OddMultivector;
    fn div(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        a.mul(b.inverse())
    }
}

impl Div<EvenMultivector> for f32 {
    type Output = EvenMultivector;
    fn div(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        a.mul(b.inverse())
    }
}

impl Div<Multivector> for f32 {
    type Output = Multivector;
    fn div(self, b: Multivector) -> Multivector {
        let a = self;
        a.mul(b.inverse())
    }
}

impl Div<f32> for Scalar {
    type Output = Scalar;
    fn div(self, b: f32) -> Scalar {
        let a = self;
        Scalar {
            s: a.s / b,
        }
    }
}

impl Div<f32> for Vector {
    type Output = Vector;
    fn div(self, b: f32) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 / b,
            e1: a.e1 / b,
            e2: a.e2 / b,
        }
    }
}

impl Div<f32> for Bivector {
    type Output = Bivector;
    fn div(self, b: f32) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 / b,
            e20: a.e20 / b,
            e12: a.e12 / b,
        }
    }
}

impl Div<f32> for Trivector {
    type Output = Trivector;
    fn div(self, b: f32) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 / b,
        }
    }
}

impl Div<f32> for Null {
    type Output = Null;
    fn div(self, b: f32) -> Null {
        let a = self;
        Null
    }
}

impl Div<f32> for OddMultivector {
    type Output = OddMultivector;
    fn div(self, b: f32) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 / b,
            e1: a.e1 / b,
            e2: a.e2 / b,
            e012: a.e012 / b,
        }
    }
}

impl Div<f32> for EvenMultivector {
    type Output = EvenMultivector;
    fn div(self, b: f32) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s / b,
            e01: a.e01 / b,
            e20: a.e20 / b,
            e12: a.e12 / b,
        }
    }
}

impl Div<f32> for Multivector {
    type Output = Multivector;
    fn div(self, b: f32) -> Multivector {
        let a = self;
        Multivector {
            s: a.s / b,
            e0: a.e0 / b,
            e1: a.e1 / b,
            e2: a.e2 / b,
            e01: a.e01 / b,
            e20: a.e20 / b,
            e12: a.e12 / b,
            e012: a.e012 / b,
        }
    }
}

impl AddAssign<Scalar> for f32 {
    fn add_assign(&mut self, b: Scalar) {
        let a = self;
        *a += b.s;
    }
}

impl AddAssign<f32> for Scalar {
    fn add_assign(&mut self, b: f32) {
        let a = self;
        a.s += b;
    }
}

impl AddAssign<Scalar> for Scalar {
    fn add_assign(&mut self, b: Scalar) {
        let a = self;
        a.s += b.s;
    }
}

impl AddAssign<Vector> for Vector {
    fn add_assign(&mut self, b: Vector) {
        let a = self;
        a.e0 += b.e0;
        a.e1 += b.e1;
        a.e2 += b.e2;
    }
}

impl AddAssign<Bivector> for Bivector {
    fn add_assign(&mut self, b: Bivector) {
        let a = self;
        a.e01 += b.e01;
        a.e20 += b.e20;
        a.e12 += b.e12;
    }
}

impl AddAssign<Trivector> for Trivector {
    fn add_assign(&mut self, b: Trivector) {
        let a = self;
        a.e012 += b.e012;
    }
}

impl AddAssign<Null> for Null {
    fn add_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl AddAssign<Vector> for OddMultivector {
    fn add_assign(&mut self, b: Vector) {
        let a = self;
        a.e0 += b.e0;
        a.e1 += b.e1;
        a.e2 += b.e2;
    }
}

impl AddAssign<Trivector> for OddMultivector {
    fn add_assign(&mut self, b: Trivector) {
        let a = self;
        a.e012 += b.e012;
    }
}

impl AddAssign<Null> for OddMultivector {
    fn add_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl AddAssign<OddMultivector> for OddMultivector {
    fn add_assign(&mut self, b: OddMultivector) {
        let a = self;
        a.e0 += b.e0;
        a.e1 += b.e1;
        a.e2 += b.e2;
        a.e012 += b.e012;
    }
}

impl AddAssign<f32> for EvenMultivector {
    fn add_assign(&mut self, b: f32) {
        let a = self;
        a.s += b;
    }
}

impl AddAssign<Scalar> for EvenMultivector {
    fn add_assign(&mut self, b: Scalar) {
        let a = self;
        a.s += b.s;
    }
}

impl AddAssign<Bivector> for EvenMultivector {
    fn add_assign(&mut self, b: Bivector) {
        let a = self;
        a.e01 += b.e01;
        a.e20 += b.e20;
        a.e12 += b.e12;
    }
}

impl AddAssign<Null> for EvenMultivector {
    fn add_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl AddAssign<EvenMultivector> for EvenMultivector {
    fn add_assign(&mut self, b: EvenMultivector) {
        let a = self;
        a.s += b.s;
        a.e01 += b.e01;
        a.e20 += b.e20;
        a.e12 += b.e12;
    }
}

impl AddAssign<f32> for Multivector {
    fn add_assign(&mut self, b: f32) {
        let a = self;
        a.s += b;
    }
}

impl AddAssign<Scalar> for Multivector {
    fn add_assign(&mut self, b: Scalar) {
        let a = self;
        a.s += b.s;
    }
}

impl AddAssign<Vector> for Multivector {
    fn add_assign(&mut self, b: Vector) {
        let a = self;
        a.e0 += b.e0;
        a.e1 += b.e1;
        a.e2 += b.e2;
    }
}

impl AddAssign<Bivector> for Multivector {
    fn add_assign(&mut self, b: Bivector) {
        let a = self;
        a.e01 += b.e01;
        a.e20 += b.e20;
        a.e12 += b.e12;
    }
}

impl AddAssign<Trivector> for Multivector {
    fn add_assign(&mut self, b: Trivector) {
        let a = self;
        a.e012 += b.e012;
    }
}

impl AddAssign<Null> for Multivector {
    fn add_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl AddAssign<OddMultivector> for Multivector {
    fn add_assign(&mut self, b: OddMultivector) {
        let a = self;
        a.e0 += b.e0;
        a.e1 += b.e1;
        a.e2 += b.e2;
        a.e012 += b.e012;
    }
}

impl AddAssign<EvenMultivector> for Multivector {
    fn add_assign(&mut self, b: EvenMultivector) {
        let a = self;
        a.s += b.s;
        a.e01 += b.e01;
        a.e20 += b.e20;
        a.e12 += b.e12;
    }
}

impl AddAssign<Multivector> for Multivector {
    fn add_assign(&mut self, b: Multivector) {
        let a = self;
        a.s += b.s;
        a.e0 += b.e0;
        a.e1 += b.e1;
        a.e2 += b.e2;
        a.e01 += b.e01;
        a.e20 += b.e20;
        a.e12 += b.e12;
        a.e012 += b.e012;
    }
}

impl SubAssign<Scalar> for f32 {
    fn sub_assign(&mut self, b: Scalar) {
        let a = self;
        *a -= b.s;
    }
}

impl SubAssign<f32> for Scalar {
    fn sub_assign(&mut self, b: f32) {
        let a = self;
        a.s -= b;
    }
}

impl SubAssign<Scalar> for Scalar {
    fn sub_assign(&mut self, b: Scalar) {
        let a = self;
        a.s -= b.s;
    }
}

impl SubAssign<Vector> for Vector {
    fn sub_assign(&mut self, b: Vector) {
        let a = self;
        a.e0 -= b.e0;
        a.e1 -= b.e1;
        a.e2 -= b.e2;
    }
}

impl SubAssign<Bivector> for Bivector {
    fn sub_assign(&mut self, b: Bivector) {
        let a = self;
        a.e01 -= b.e01;
        a.e20 -= b.e20;
        a.e12 -= b.e12;
    }
}

impl SubAssign<Trivector> for Trivector {
    fn sub_assign(&mut self, b: Trivector) {
        let a = self;
        a.e012 -= b.e012;
    }
}

impl SubAssign<Null> for Null {
    fn sub_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl SubAssign<Vector> for OddMultivector {
    fn sub_assign(&mut self, b: Vector) {
        let a = self;
        a.e0 -= b.e0;
        a.e1 -= b.e1;
        a.e2 -= b.e2;
    }
}

impl SubAssign<Trivector> for OddMultivector {
    fn sub_assign(&mut self, b: Trivector) {
        let a = self;
        a.e012 -= b.e012;
    }
}

impl SubAssign<Null> for OddMultivector {
    fn sub_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl SubAssign<OddMultivector> for OddMultivector {
    fn sub_assign(&mut self, b: OddMultivector) {
        let a = self;
        a.e0 -= b.e0;
        a.e1 -= b.e1;
        a.e2 -= b.e2;
        a.e012 -= b.e012;
    }
}

impl SubAssign<f32> for EvenMultivector {
    fn sub_assign(&mut self, b: f32) {
        let a = self;
        a.s -= b;
    }
}

impl SubAssign<Scalar> for EvenMultivector {
    fn sub_assign(&mut self, b: Scalar) {
        let a = self;
        a.s -= b.s;
    }
}

impl SubAssign<Bivector> for EvenMultivector {
    fn sub_assign(&mut self, b: Bivector) {
        let a = self;
        a.e01 -= b.e01;
        a.e20 -= b.e20;
        a.e12 -= b.e12;
    }
}

impl SubAssign<Null> for EvenMultivector {
    fn sub_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl SubAssign<EvenMultivector> for EvenMultivector {
    fn sub_assign(&mut self, b: EvenMultivector) {
        let a = self;
        a.s -= b.s;
        a.e01 -= b.e01;
        a.e20 -= b.e20;
        a.e12 -= b.e12;
    }
}

impl SubAssign<f32> for Multivector {
    fn sub_assign(&mut self, b: f32) {
        let a = self;
        a.s -= b;
    }
}

impl SubAssign<Scalar> for Multivector {
    fn sub_assign(&mut self, b: Scalar) {
        let a = self;
        a.s -= b.s;
    }
}

impl SubAssign<Vector> for Multivector {
    fn sub_assign(&mut self, b: Vector) {
        let a = self;
        a.e0 -= b.e0;
        a.e1 -= b.e1;
        a.e2 -= b.e2;
    }
}

impl SubAssign<Bivector> for Multivector {
    fn sub_assign(&mut self, b: Bivector) {
        let a = self;
        a.e01 -= b.e01;
        a.e20 -= b.e20;
        a.e12 -= b.e12;
    }
}

impl SubAssign<Trivector> for Multivector {
    fn sub_assign(&mut self, b: Trivector) {
        let a = self;
        a.e012 -= b.e012;
    }
}

impl SubAssign<Null> for Multivector {
    fn sub_assign(&mut self, b: Null) {
        let a = self;
    }
}

impl SubAssign<OddMultivector> for Multivector {
    fn sub_assign(&mut self, b: OddMultivector) {
        let a = self;
        a.e0 -= b.e0;
        a.e1 -= b.e1;
        a.e2 -= b.e2;
        a.e012 -= b.e012;
    }
}

impl SubAssign<EvenMultivector> for Multivector {
    fn sub_assign(&mut self, b: EvenMultivector) {
        let a = self;
        a.s -= b.s;
        a.e01 -= b.e01;
        a.e20 -= b.e20;
        a.e12 -= b.e12;
    }
}

impl SubAssign<Multivector> for Multivector {
    fn sub_assign(&mut self, b: Multivector) {
        let a = self;
        a.s -= b.s;
        a.e0 -= b.e0;
        a.e1 -= b.e1;
        a.e2 -= b.e2;
        a.e01 -= b.e01;
        a.e20 -= b.e20;
        a.e12 -= b.e12;
        a.e012 -= b.e012;
    }
}

impl MulAssign<f32> for Scalar {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
        a.s *= b;
    }
}

impl MulAssign<f32> for Vector {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
        a.e0 *= b;
        a.e1 *= b;
        a.e2 *= b;
    }
}

impl MulAssign<f32> for Bivector {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
        a.e01 *= b;
        a.e20 *= b;
        a.e12 *= b;
    }
}

impl MulAssign<f32> for Trivector {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
        a.e012 *= b;
    }
}

impl MulAssign<f32> for Null {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
    }
}

impl MulAssign<f32> for OddMultivector {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
        a.e0 *= b;
        a.e1 *= b;
        a.e2 *= b;
        a.e012 *= b;
    }
}

impl MulAssign<f32> for EvenMultivector {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
        a.s *= b;
        a.e01 *= b;
        a.e20 *= b;
        a.e12 *= b;
    }
}

impl MulAssign<f32> for Multivector {
    fn mul_assign(&mut self, b: f32) {
        let a = self;
        a.s *= b;
        a.e0 *= b;
        a.e1 *= b;
        a.e2 *= b;
        a.e01 *= b;
        a.e20 *= b;
        a.e12 *= b;
        a.e012 *= b;
    }
}

impl DivAssign<f32> for Scalar {
    fn div_assign(&mut self, b: f32) {
        let a = self;
        a.s /= b;
    }
}

impl DivAssign<f32> for Vector {
    fn div_assign(&mut self, b: f32) {
        let a = self;
        a.e0 /= b;
        a.e1 /= b;
        a.e2 /= b;
    }
}

impl DivAssign<f32> for Bivector {
    fn div_assign(&mut self, b: f32) {
        let a = self;
        a.e01 /= b;
        a.e20 /= b;
        a.e12 /= b;
    }
}

impl DivAssign<f32> for Trivector {
    fn div_assign(&mut self, b: f32) {
        let a = self;
        a.e012 /= b;
    }
}

impl DivAssign<f32> for Null {
    fn div_assign(&mut self, b: f32) {
        let a = self;
    }
}

impl DivAssign<f32> for OddMultivector {
    fn div_assign(&mut self, b: f32) {
        let a = self;
        a.e0 /= b;
        a.e1 /= b;
        a.e2 /= b;
        a.e012 /= b;
    }
}

impl DivAssign<f32> for EvenMultivector {
    fn div_assign(&mut self, b: f32) {
        let a = self;
        a.s /= b;
        a.e01 /= b;
        a.e20 /= b;
        a.e12 /= b;
    }
}

impl DivAssign<f32> for Multivector {
    fn div_assign(&mut self, b: f32) {
        let a = self;
        a.s /= b;
        a.e0 /= b;
        a.e1 /= b;
        a.e2 /= b;
        a.e01 /= b;
        a.e20 /= b;
        a.e12 /= b;
        a.e012 /= b;
    }
}

impl Zero for Scalar {
    fn zero() -> Scalar {
        Scalar {
            s: 0.0,
        }
    }
}

impl Zero for Vector {
    fn zero() -> Vector {
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl Zero for Bivector {
    fn zero() -> Bivector {
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Zero for Trivector {
    fn zero() -> Trivector {
        Trivector {
            e012: 0.0,
        }
    }
}

impl Zero for Null {
    fn zero() -> Null {
        Null
    }
}

impl Zero for OddMultivector {
    fn zero() -> OddMultivector {
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Zero for EvenMultivector {
    fn zero() -> EvenMultivector {
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Zero for Multivector {
    fn zero() -> Multivector {
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl One for Scalar {
    fn one() -> Scalar {
        Scalar {
            s: 1.0,
        }
    }
}

impl One for EvenMultivector {
    fn one() -> EvenMultivector {
        EvenMultivector {
            s: 1.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl One for Multivector {
    fn one() -> Multivector {
        Multivector {
            s: 1.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Involute for Scalar {
    type Output = Scalar;
    fn involute(self) -> Scalar {
        let a = self;
        Scalar {
            s: a.s,
        }
    }
}

impl Involute for Vector {
    type Output = Vector;
    fn involute(self) -> Vector {
        let a = self;
        Vector {
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
        }
    }
}

impl Involute for Bivector {
    type Output = Bivector;
    fn involute(self) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Involute for Trivector {
    type Output = Trivector;
    fn involute(self) -> Trivector {
        let a = self;
        Trivector {
            e012: -a.e012,
        }
    }
}

impl Involute for Null {
    type Output = Null;
    fn involute(self) -> Null {
        let a = self;
        Null
    }
}

impl Involute for OddMultivector {
    type Output = OddMultivector;
    fn involute(self) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
            e012: -a.e012,
        }
    }
}

impl Involute for EvenMultivector {
    type Output = EvenMultivector;
    fn involute(self) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
        }
    }
}

impl Involute for Multivector {
    type Output = Multivector;
    fn involute(self) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
            e01: a.e01,
            e20: a.e20,
            e12: a.e12,
            e012: -a.e012,
        }
    }
}

impl Reverse for Scalar {
    type Output = Scalar;
    fn reverse(self) -> Scalar {
        let a = self;
        Scalar {
            s: a.s,
        }
    }
}

impl Reverse for Vector {
    type Output = Vector;
    fn reverse(self) -> Vector {
        let a = self;
        Vector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
        }
    }
}

impl Reverse for Bivector {
    type Output = Bivector;
    fn reverse(self) -> Bivector {
        let a = self;
        Bivector {
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
        }
    }
}

impl Reverse for Trivector {
    type Output = Trivector;
    fn reverse(self) -> Trivector {
        let a = self;
        Trivector {
            e012: -a.e012,
        }
    }
}

impl Reverse for Null {
    type Output = Null;
    fn reverse(self) -> Null {
        let a = self;
        Null
    }
}

impl Reverse for OddMultivector {
    type Output = OddMultivector;
    fn reverse(self) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e012: -a.e012,
        }
    }
}

impl Reverse for EvenMultivector {
    type Output = EvenMultivector;
    fn reverse(self) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
        }
    }
}

impl Reverse for Multivector {
    type Output = Multivector;
    fn reverse(self) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: a.e0,
            e1: a.e1,
            e2: a.e2,
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
            e012: -a.e012,
        }
    }
}

impl Conjugate for Scalar {
    type Output = Scalar;
    fn conjugate(self) -> Scalar {
        let a = self;
        Scalar {
            s: a.s,
        }
    }
}

impl Conjugate for Vector {
    type Output = Vector;
    fn conjugate(self) -> Vector {
        let a = self;
        Vector {
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
        }
    }
}

impl Conjugate for Bivector {
    type Output = Bivector;
    fn conjugate(self) -> Bivector {
        let a = self;
        Bivector {
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
        }
    }
}

impl Conjugate for Trivector {
    type Output = Trivector;
    fn conjugate(self) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012,
        }
    }
}

impl Conjugate for Null {
    type Output = Null;
    fn conjugate(self) -> Null {
        let a = self;
        Null
    }
}

impl Conjugate for OddMultivector {
    type Output = OddMultivector;
    fn conjugate(self) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
            e012: a.e012,
        }
    }
}

impl Conjugate for EvenMultivector {
    type Output = EvenMultivector;
    fn conjugate(self) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s,
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
        }
    }
}

impl Conjugate for Multivector {
    type Output = Multivector;
    fn conjugate(self) -> Multivector {
        let a = self;
        Multivector {
            s: a.s,
            e0: -a.e0,
            e1: -a.e1,
            e2: -a.e2,
            e01: -a.e01,
            e20: -a.e20,
            e12: -a.e12,
            e012: a.e012,
        }
    }
}

impl Dual for Scalar {
    type Output = Trivector;
    fn dual(self) -> Trivector {
        let a = self;
        Trivector {
            e012: a.s,
        }
    }
}

impl Dual for Vector {
    type Output = Bivector;
    fn dual(self) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e2,
            e20: a.e1,
            e12: a.e0,
        }
    }
}

impl Dual for Bivector {
    type Output = Vector;
    fn dual(self) -> Vector {
        let a = self;
        Vector {
            e0: a.e12,
            e1: a.e20,
            e2: a.e01,
        }
    }
}

impl Dual for Trivector {
    type Output = Scalar;
    fn dual(self) -> Scalar {
        let a = self;
        Scalar {
            s: a.e012,
        }
    }
}

impl Dual for Null {
    type Output = Null;
    fn dual(self) -> Null {
        let a = self;
        Null
    }
}

impl Dual for OddMultivector {
    type Output = EvenMultivector;
    fn dual(self) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e012,
            e01: a.e2,
            e20: a.e1,
            e12: a.e0,
        }
    }
}

impl Dual for EvenMultivector {
    type Output = OddMultivector;
    fn dual(self) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e12,
            e1: a.e20,
            e2: a.e01,
            e012: a.s,
        }
    }
}

impl Dual for Multivector {
    type Output = Multivector;
    fn dual(self) -> Multivector {
        let a = self;
        Multivector {
            s: a.e012,
            e0: a.e12,
            e1: a.e20,
            e2: a.e01,
            e01: a.e2,
            e20: a.e1,
            e12: a.e0,
            e012: a.s,
        }
    }
}

impl Undual for Scalar {
    type Output = Trivector;
    fn undual(self) -> Trivector {
        let a = self;
        Trivector {
            e012: a.s,
        }
    }
}

impl Undual for Vector {
    type Output = Bivector;
    fn undual(self) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e2,
            e20: a.e1,
            e12: a.e0,
        }
    }
}

impl Undual for Bivector {
    type Output = Vector;
    fn undual(self) -> Vector {
        let a = self;
        Vector {
            e0: a.e12,
            e1: a.e20,
            e2: a.e01,
        }
    }
}

impl Undual for Trivector {
    type Output = Scalar;
    fn undual(self) -> Scalar {
        let a = self;
        Scalar {
            s: a.e012,
        }
    }
}

impl Undual for Null {
    type Output = Null;
    fn undual(self) -> Null {
        let a = self;
        Null
    }
}

impl Undual for OddMultivector {
    type Output = EvenMultivector;
    fn undual(self) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e012,
            e01: a.e2,
            e20: a.e1,
            e12: a.e0,
        }
    }
}

impl Undual for EvenMultivector {
    type Output = OddMultivector;
    fn undual(self) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e12,
            e1: a.e20,
            e2: a.e01,
            e012: a.s,
        }
    }
}

impl Undual for Multivector {
    type Output = Multivector;
    fn undual(self) -> Multivector {
        let a = self;
        Multivector {
            s: a.e012,
            e0: a.e12,
            e1: a.e20,
            e2: a.e01,
            e01: a.e2,
            e20: a.e1,
            e12: a.e0,
            e012: a.s,
        }
    }
}

impl NormSquared for Scalar {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        a.s * a.s
    }
}

impl NormSquared for Vector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        a.e0 * a.e0 + a.e1 * a.e1 + a.e2 * a.e2
    }
}

impl NormSquared for Bivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        a.e01 * a.e01 + a.e20 * a.e20 + a.e12 * a.e12
    }
}

impl NormSquared for Trivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        a.e012 * a.e012
    }
}

impl NormSquared for Null {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        0.0
    }
}

impl NormSquared for OddMultivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        a.e0 * a.e0 + a.e1 * a.e1 + a.e2 * a.e2 + a.e012 * a.e012
    }
}

impl NormSquared for EvenMultivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        a.s * a.s + a.e01 * a.e01 + a.e20 * a.e20 + a.e12 * a.e12
    }
}

impl NormSquared for Multivector {
    type Output = f32;
    fn norm_squared(self) -> f32 {
        let a = self;
        a.s * a.s + a.e0 * a.e0 + a.e1 * a.e1 + a.e2 * a.e2 + a.e01 * a.e01 + a.e20 * a.e20 + a.e12 * a.e12 + a.e012 * a.e012
    }
}

impl Norm for Scalar {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Norm for Vector {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Norm for Bivector {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Norm for Trivector {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Norm for Null {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Norm for OddMultivector {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Norm for EvenMultivector {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Norm for Multivector {
    type Output = f32;
    fn norm(self) -> f32 {
        let a = self;
        a.norm_squared().abs().sqrt()
    }
}

impl Normalized for Scalar {
    type Output = Scalar;
    fn normalized(self) -> Scalar {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalized for Vector {
    type Output = Vector;
    fn normalized(self) -> Vector {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalized for Bivector {
    type Output = Bivector;
    fn normalized(self) -> Bivector {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalized for Trivector {
    type Output = Trivector;
    fn normalized(self) -> Trivector {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalized for Null {
    type Output = Null;
    fn normalized(self) -> Null {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalized for OddMultivector {
    type Output = OddMultivector;
    fn normalized(self) -> OddMultivector {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalized for EvenMultivector {
    type Output = EvenMultivector;
    fn normalized(self) -> EvenMultivector {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalized for Multivector {
    type Output = Multivector;
    fn normalized(self) -> Multivector {
        let a = self;
        a.div(a.norm())
    }
}

impl Normalize for Scalar {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Normalize for Vector {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Normalize for Bivector {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Normalize for Trivector {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Normalize for Null {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Normalize for OddMultivector {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Normalize for EvenMultivector {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Normalize for Multivector {
    fn normalize(&mut self) {
        let a = self;
        a.div_assign(a.norm());
    }
}

impl Inverse for Scalar {
    type Output = EvenMultivector;
    fn inverse(self) -> EvenMultivector {
        let a = self;
        let mut adjoint = EvenMultivector::from(a);
        adjoint.s *= 1.0 - 4.0 / 1.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 2.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 3.0;
        adjoint.div_assign(a.scalar_product(adjoint));
        adjoint
    }
}

impl Inverse for Vector {
    type Output = OddMultivector;
    fn inverse(self) -> OddMultivector {
        let a = self;
        let mut adjoint = OddMultivector::from(a);
        let mut coadjoint = a.geometric_product(adjoint);
        coadjoint.s *= 1.0 - 4.0 / 2.0;
        adjoint = a.geometric_product(coadjoint);
        adjoint.div_assign(a.scalar_product(adjoint));
        adjoint
    }
}

impl Inverse for Bivector {
    type Output = EvenMultivector;
    fn inverse(self) -> EvenMultivector {
        let a = self;
        let mut adjoint = EvenMultivector::from(a);
        adjoint.s *= 1.0 - 4.0 / 1.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 2.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 3.0;
        adjoint.div_assign(a.scalar_product(adjoint));
        adjoint
    }
}

impl Inverse for Trivector {
    type Output = OddMultivector;
    fn inverse(self) -> OddMultivector {
        let a = self;
        let mut adjoint = OddMultivector::from(a);
        let mut coadjoint = a.geometric_product(adjoint);
        coadjoint.s *= 1.0 - 4.0 / 2.0;
        adjoint = a.geometric_product(coadjoint);
        adjoint.div_assign(a.scalar_product(adjoint));
        adjoint
    }
}

impl Inverse for OddMultivector {
    type Output = OddMultivector;
    fn inverse(self) -> OddMultivector {
        let a = self;
        let mut adjoint = a;
        let mut coadjoint = a.geometric_product(adjoint);
        coadjoint.s *= 1.0 - 4.0 / 2.0;
        adjoint = a.geometric_product(coadjoint);
        adjoint.div_assign(a.scalar_product(adjoint));
        adjoint
    }
}

impl Inverse for EvenMultivector {
    type Output = EvenMultivector;
    fn inverse(self) -> EvenMultivector {
        let a = self;
        let mut adjoint = a;
        adjoint.s *= 1.0 - 4.0 / 1.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 2.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 3.0;
        adjoint.div_assign(a.scalar_product(adjoint));
        adjoint
    }
}

impl Inverse for Multivector {
    type Output = Multivector;
    fn inverse(self) -> Multivector {
        let a = self;
        let mut adjoint = a;
        adjoint.s *= 1.0 - 4.0 / 1.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 2.0;
        adjoint = a.geometric_product(adjoint);
        adjoint.s *= 1.0 - 4.0 / 3.0;
        adjoint.div_assign(a.scalar_product(adjoint));
        adjoint
    }
}

impl GeometricProduct<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl GeometricProduct<Vector> for Scalar {
    type Output = OddMultivector;
    fn geometric_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: 0.0,
        }
    }
}

impl GeometricProduct<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl GeometricProduct<Trivector> for Scalar {
    type Output = OddMultivector;
    fn geometric_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.s * b.e012,
        }
    }
}

impl GeometricProduct<Null> for Scalar {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn geometric_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.s * b.e012,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn geometric_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl GeometricProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn geometric_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.s * b.e012,
        }
    }
}

impl GeometricProduct<Scalar> for Vector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: 0.0,
        }
    }
}

impl GeometricProduct<Vector> for Vector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl GeometricProduct<Bivector> for Vector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl GeometricProduct<Trivector> for Vector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl GeometricProduct<Null> for Vector {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e2 * b.e012,
            e20: -a.e0 * b.e2 + a.e1 * b.e012 + a.e2 * b.e0,
            e12: a.e0 * b.e012 + a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn geometric_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl GeometricProduct<Multivector> for Vector {
    type Output = Multivector;
    fn geometric_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e2 * b.e012,
            e20: -a.e0 * b.e2 + a.e1 * b.e012 + a.e2 * b.e0,
            e12: a.e0 * b.e012 + a.e1 * b.e2 - a.e2 * b.e1,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl GeometricProduct<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl GeometricProduct<Vector> for Bivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
        }
    }
}

impl GeometricProduct<Trivector> for Bivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: 0.0,
        }
    }
}

impl GeometricProduct<Null> for Bivector {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: -a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: -a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.e01 * b.s + a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e20 * b.s + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01 + a.e12 * b.s,
        }
    }
}

impl GeometricProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn geometric_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: -a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: -a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e01 * b.s + a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e20 * b.s + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01 + a.e12 * b.s,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<Scalar> for Trivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Vector> for Trivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl GeometricProduct<Bivector> for Trivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: 0.0,
        }
    }
}

impl GeometricProduct<Trivector> for Trivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl GeometricProduct<Null> for Trivector {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Multivector> for Trivector {
    type Output = Multivector;
    fn geometric_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Scalar> for Null {
    type Output = Null;
    fn geometric_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<Vector> for Null {
    type Output = Null;
    fn geometric_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<Bivector> for Null {
    type Output = Null;
    fn geometric_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<Trivector> for Null {
    type Output = Null;
    fn geometric_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<Null> for Null {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for Null {
    type Output = Null;
    fn geometric_product(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<EvenMultivector> for Null {
    type Output = Null;
    fn geometric_product(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<Multivector> for Null {
    type Output = Null;
    fn geometric_product(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e012 * b.e2,
            e20: -a.e0 * b.e2 + a.e2 * b.e0 + a.e012 * b.e1,
            e12: a.e1 * b.e2 - a.e2 * b.e1 + a.e012 * b.e0,
        }
    }
}

impl GeometricProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 - a.e012 * b.e01,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl GeometricProduct<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl GeometricProduct<Null> for OddMultivector {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e2 * b.e012 + a.e012 * b.e2,
            e20: -a.e0 * b.e2 + a.e1 * b.e012 + a.e2 * b.e0 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e1 * b.e2 - a.e2 * b.e1 + a.e012 * b.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e012 * b.e01,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn geometric_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e012 * b.e01,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e2 * b.e012 + a.e012 * b.e2,
            e20: -a.e0 * b.e2 + a.e1 * b.e012 + a.e2 * b.e0 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e1 * b.e2 - a.e2 * b.e1 + a.e012 * b.e0,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl GeometricProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2,
            e1: a.s * b.e1 - a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.s * b.e2 + a.e20 * b.e0 - a.e12 * b.e1,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01 + a.e20 * b.e12 - a.e12 * b.e20,
            e20: a.s * b.e20 - a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.s * b.e12 + a.e01 * b.e20 - a.e20 * b.e01,
        }
    }
}

impl GeometricProduct<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl GeometricProduct<Null> for EvenMultivector {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn geometric_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: a.s * b.e2 - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn geometric_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01 + a.e01 * b.s + a.e20 * b.e12 - a.e12 * b.e20,
            e20: a.s * b.e20 - a.e01 * b.e12 + a.e20 * b.s + a.e12 * b.e01,
            e12: a.s * b.e12 + a.e01 * b.e20 - a.e20 * b.e01 + a.e12 * b.s,
        }
    }
}

impl GeometricProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn geometric_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: a.s * b.e2 - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.s * b.e01 + a.e01 * b.s + a.e20 * b.e12 - a.e12 * b.e20,
            e20: a.s * b.e20 - a.e01 * b.e12 + a.e20 * b.s + a.e12 * b.e01,
            e12: a.s * b.e12 + a.e01 * b.e20 - a.e20 * b.e01 + a.e12 * b.s,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Vector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2,
            e1: a.s * b.e1 - a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.s * b.e2 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e012 * b.e2,
            e20: -a.e0 * b.e2 + a.e2 * b.e0 + a.e012 * b.e1,
            e12: a.e1 * b.e2 - a.e2 * b.e1 + a.e012 * b.e0,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 - a.e012 * b.e01,
            e01: a.s * b.e01 + a.e20 * b.e12 - a.e12 * b.e20,
            e20: a.s * b.e20 - a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.s * b.e12 + a.e01 * b.e20 - a.e20 * b.e01,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl GeometricProduct<Trivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl GeometricProduct<Null> for Multivector {
    type Output = Null;
    fn geometric_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl GeometricProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: a.s * b.e2 - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e2 * b.e012 + a.e012 * b.e2,
            e20: -a.e0 * b.e2 + a.e1 * b.e012 + a.e2 * b.e0 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e1 * b.e2 - a.e2 * b.e1 + a.e012 * b.e0,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl GeometricProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e012 * b.e01,
            e01: a.s * b.e01 + a.e01 * b.s + a.e20 * b.e12 - a.e12 * b.e20,
            e20: a.s * b.e20 - a.e01 * b.e12 + a.e20 * b.s + a.e12 * b.e01,
            e12: a.s * b.e12 + a.e01 * b.e20 - a.e20 * b.e01 + a.e12 * b.s,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl GeometricProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn geometric_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s + a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12 - a.e012 * b.e012,
            e0: a.s * b.e0 + a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012 - a.e012 * b.e12,
            e1: a.s * b.e1 + a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2 - a.e012 * b.e20,
            e2: a.s * b.e2 - a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1 - a.e012 * b.e01,
            e01: a.s * b.e01 + a.e0 * b.e1 - a.e1 * b.e0 + a.e2 * b.e012 + a.e01 * b.s + a.e20 * b.e12 - a.e12 * b.e20 + a.e012 * b.e2,
            e20: a.s * b.e20 - a.e0 * b.e2 + a.e1 * b.e012 + a.e2 * b.e0 - a.e01 * b.e12 + a.e20 * b.s + a.e12 * b.e01 + a.e012 * b.e1,
            e12: a.s * b.e12 + a.e0 * b.e012 + a.e1 * b.e2 - a.e2 * b.e1 + a.e01 * b.e20 - a.e20 * b.e01 + a.e12 * b.s + a.e012 * b.e0,
            e012: a.s * b.e012 + a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0 + a.e012 * b.s,
        }
    }
}

impl ScalarProduct<Scalar> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        a.s * b.s
    }
}

impl ScalarProduct<Vector> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Bivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Trivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Null> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        a.s * b.s
    }
}

impl ScalarProduct<Multivector> for Scalar {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        a.s * b.s
    }
}

impl ScalarProduct<Scalar> for Vector {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Vector> for Vector {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2
    }
}

impl ScalarProduct<Bivector> for Vector {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Trivector> for Vector {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Null> for Vector {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Vector {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2
    }
}

impl ScalarProduct<EvenMultivector> for Vector {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Multivector> for Vector {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2
    }
}

impl ScalarProduct<Scalar> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Vector> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Bivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Trivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Null> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Multivector> for Bivector {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Scalar> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Vector> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Bivector> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Trivector> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        -a.e012 * b.e012
    }
}

impl ScalarProduct<Null> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        -a.e012 * b.e012
    }
}

impl ScalarProduct<EvenMultivector> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Multivector> for Trivector {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        -a.e012 * b.e012
    }
}

impl ScalarProduct<Scalar> for Null {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Vector> for Null {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Bivector> for Null {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Trivector> for Null {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Null> for Null {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Null {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for Null {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Multivector> for Null {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Scalar> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Vector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2
    }
}

impl ScalarProduct<Bivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Trivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        -a.e012 * b.e012
    }
}

impl ScalarProduct<Null> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012
    }
}

impl ScalarProduct<EvenMultivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Multivector> for OddMultivector {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012
    }
}

impl ScalarProduct<Scalar> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        a.s * b.s
    }
}

impl ScalarProduct<Vector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Bivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Trivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<Null> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<EvenMultivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Multivector> for EvenMultivector {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Scalar> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: Scalar) -> f32 {
        let a = self;
        a.s * b.s
    }
}

impl ScalarProduct<Vector> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: Vector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2
    }
}

impl ScalarProduct<Bivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: Bivector) -> f32 {
        let a = self;
        -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Trivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: Trivector) -> f32 {
        let a = self;
        -a.e012 * b.e012
    }
}

impl ScalarProduct<Null> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: Null) -> f32 {
        let a = self;
        0.0
    }
}

impl ScalarProduct<OddMultivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: OddMultivector) -> f32 {
        let a = self;
        a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012
    }
}

impl ScalarProduct<EvenMultivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: EvenMultivector) -> f32 {
        let a = self;
        a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12
    }
}

impl ScalarProduct<Multivector> for Multivector {
    type Output = f32;
    fn scalar_product(self, b: Multivector) -> f32 {
        let a = self;
        a.s * b.s + a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12 - a.e012 * b.e012
    }
}

impl LeftInnerProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn left_inner_product(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s,
        }
    }
}

impl LeftInnerProduct<Vector> for Scalar {
    type Output = Vector;
    fn left_inner_product(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
        }
    }
}

impl LeftInnerProduct<Bivector> for Scalar {
    type Output = Bivector;
    fn left_inner_product(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl LeftInnerProduct<Trivector> for Scalar {
    type Output = Trivector;
    fn left_inner_product(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<Null> for Scalar {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn left_inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl LeftInnerProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn left_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<Scalar> for Vector {
    type Output = Null;
    fn left_inner_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Vector> for Vector {
    type Output = Scalar;
    fn left_inner_product(self, b: Vector) -> Scalar {
        let a = self;
        Scalar {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
        }
    }
}

impl LeftInnerProduct<Bivector> for Vector {
    type Output = Vector;
    fn left_inner_product(self, b: Bivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
        }
    }
}

impl LeftInnerProduct<Trivector> for Vector {
    type Output = Bivector;
    fn left_inner_product(self, b: Trivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl LeftInnerProduct<Null> for Vector {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for Vector {
    type Output = Multivector;
    fn left_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Scalar> for Bivector {
    type Output = Null;
    fn left_inner_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Vector> for Bivector {
    type Output = Null;
    fn left_inner_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Bivector> for Bivector {
    type Output = Scalar;
    fn left_inner_product(self, b: Bivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
        }
    }
}

impl LeftInnerProduct<Trivector> for Bivector {
    type Output = Vector;
    fn left_inner_product(self, b: Trivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
        }
    }
}

impl LeftInnerProduct<Null> for Bivector {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Scalar> for Trivector {
    type Output = Null;
    fn left_inner_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Vector> for Trivector {
    type Output = Null;
    fn left_inner_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Bivector> for Trivector {
    type Output = Null;
    fn left_inner_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Trivector> for Trivector {
    type Output = Scalar;
    fn left_inner_product(self, b: Trivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.e012 * b.e012,
        }
    }
}

impl LeftInnerProduct<Null> for Trivector {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for Trivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Scalar> for Null {
    type Output = Null;
    fn left_inner_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Vector> for Null {
    type Output = Null;
    fn left_inner_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Bivector> for Null {
    type Output = Null;
    fn left_inner_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Trivector> for Null {
    type Output = Null;
    fn left_inner_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Null> for Null {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Null {
    type Output = Null;
    fn left_inner_product(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<EvenMultivector> for Null {
    type Output = Null;
    fn left_inner_product(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Multivector> for Null {
    type Output = Null;
    fn left_inner_product(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl LeftInnerProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl LeftInnerProduct<Null> for OddMultivector {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl LeftInnerProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl LeftInnerProduct<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<Null> for EvenMultivector {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn left_inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e20 * b.e012,
            e2: a.s * b.e2 - a.e01 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn left_inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl LeftInnerProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.s * b.e0 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e20 * b.e012,
            e2: a.s * b.e2 - a.e01 * b.e012,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Vector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Trivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<Null> for Multivector {
    type Output = Null;
    fn left_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl LeftInnerProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.s * b.e0 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e20 * b.e012,
            e2: a.s * b.e2 - a.e01 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl LeftInnerProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: 0.0,
        }
    }
}

impl LeftInnerProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn left_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s + a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12 - a.e012 * b.e012,
            e0: a.s * b.e0 - a.e1 * b.e01 + a.e2 * b.e20 - a.e12 * b.e012,
            e1: a.s * b.e1 + a.e0 * b.e01 - a.e2 * b.e12 - a.e20 * b.e012,
            e2: a.s * b.e2 - a.e0 * b.e20 + a.e1 * b.e12 - a.e01 * b.e012,
            e01: a.s * b.e01 + a.e2 * b.e012,
            e20: a.s * b.e20 + a.e1 * b.e012,
            e12: a.s * b.e12 + a.e0 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl RightInnerProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn right_inner_product(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s,
        }
    }
}

impl RightInnerProduct<Vector> for Scalar {
    type Output = Null;
    fn right_inner_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Bivector> for Scalar {
    type Output = Null;
    fn right_inner_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Trivector> for Scalar {
    type Output = Null;
    fn right_inner_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Null> for Scalar {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn right_inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RightInnerProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn right_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Scalar> for Vector {
    type Output = Vector;
    fn right_inner_product(self, b: Scalar) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
        }
    }
}

impl RightInnerProduct<Vector> for Vector {
    type Output = Scalar;
    fn right_inner_product(self, b: Vector) -> Scalar {
        let a = self;
        Scalar {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
        }
    }
}

impl RightInnerProduct<Bivector> for Vector {
    type Output = Null;
    fn right_inner_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Trivector> for Vector {
    type Output = Null;
    fn right_inner_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Null> for Vector {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Multivector> for Vector {
    type Output = Multivector;
    fn right_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Scalar> for Bivector {
    type Output = Bivector;
    fn right_inner_product(self, b: Scalar) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl RightInnerProduct<Vector> for Bivector {
    type Output = Vector;
    fn right_inner_product(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
        }
    }
}

impl RightInnerProduct<Bivector> for Bivector {
    type Output = Scalar;
    fn right_inner_product(self, b: Bivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
        }
    }
}

impl RightInnerProduct<Trivector> for Bivector {
    type Output = Null;
    fn right_inner_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Null> for Bivector {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl RightInnerProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Scalar> for Trivector {
    type Output = Trivector;
    fn right_inner_product(self, b: Scalar) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Vector> for Trivector {
    type Output = Bivector;
    fn right_inner_product(self, b: Vector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl RightInnerProduct<Bivector> for Trivector {
    type Output = Vector;
    fn right_inner_product(self, b: Bivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
        }
    }
}

impl RightInnerProduct<Trivector> for Trivector {
    type Output = Scalar;
    fn right_inner_product(self, b: Trivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.e012 * b.e012,
        }
    }
}

impl RightInnerProduct<Null> for Trivector {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Multivector> for Trivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Scalar> for Null {
    type Output = Null;
    fn right_inner_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Vector> for Null {
    type Output = Null;
    fn right_inner_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Bivector> for Null {
    type Output = Null;
    fn right_inner_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Trivector> for Null {
    type Output = Null;
    fn right_inner_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Null> for Null {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Null {
    type Output = Null;
    fn right_inner_product(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<EvenMultivector> for Null {
    type Output = Null;
    fn right_inner_product(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Multivector> for Null {
    type Output = Null;
    fn right_inner_product(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl RightInnerProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RightInnerProduct<Null> for OddMultivector {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s - a.e012 * b.e12,
            e1: a.e1 * b.s - a.e012 * b.e20,
            e2: a.e2 * b.s - a.e012 * b.e01,
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.e0 * b.s - a.e012 * b.e12,
            e1: a.e1 * b.s - a.e012 * b.e20,
            e2: a.e2 * b.s - a.e012 * b.e01,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl RightInnerProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RightInnerProduct<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Null> for EvenMultivector {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn right_inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn right_inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl RightInnerProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Vector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Trivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<Null> for Multivector {
    type Output = Null;
    fn right_inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RightInnerProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: 0.0,
        }
    }
}

impl RightInnerProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e0 * b.s - a.e012 * b.e12,
            e1: a.e1 * b.s - a.e012 * b.e20,
            e2: a.e2 * b.s - a.e012 * b.e01,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl RightInnerProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn right_inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s + a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12 - a.e012 * b.e012,
            e0: a.e0 * b.s + a.e01 * b.e1 - a.e20 * b.e2 - a.e012 * b.e12,
            e1: a.e1 * b.s - a.e01 * b.e0 + a.e12 * b.e2 - a.e012 * b.e20,
            e2: a.e2 * b.s + a.e20 * b.e0 - a.e12 * b.e1 - a.e012 * b.e01,
            e01: a.e01 * b.s + a.e012 * b.e2,
            e20: a.e20 * b.s + a.e012 * b.e1,
            e12: a.e12 * b.s + a.e012 * b.e0,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn inner_product(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s,
        }
    }
}

impl InnerProduct<Vector> for Scalar {
    type Output = Vector;
    fn inner_product(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
        }
    }
}

impl InnerProduct<Bivector> for Scalar {
    type Output = Bivector;
    fn inner_product(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl InnerProduct<Trivector> for Scalar {
    type Output = Trivector;
    fn inner_product(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<Null> for Scalar {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl InnerProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<Scalar> for Vector {
    type Output = Vector;
    fn inner_product(self, b: Scalar) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
        }
    }
}

impl InnerProduct<Vector> for Vector {
    type Output = Scalar;
    fn inner_product(self, b: Vector) -> Scalar {
        let a = self;
        Scalar {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
        }
    }
}

impl InnerProduct<Bivector> for Vector {
    type Output = Vector;
    fn inner_product(self, b: Bivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
        }
    }
}

impl InnerProduct<Trivector> for Vector {
    type Output = Bivector;
    fn inner_product(self, b: Trivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl InnerProduct<Null> for Vector {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl InnerProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s,
            e012: 0.0,
        }
    }
}

impl InnerProduct<Multivector> for Vector {
    type Output = Multivector;
    fn inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: 0.0,
        }
    }
}

impl InnerProduct<Scalar> for Bivector {
    type Output = Bivector;
    fn inner_product(self, b: Scalar) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl InnerProduct<Vector> for Bivector {
    type Output = Vector;
    fn inner_product(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
        }
    }
}

impl InnerProduct<Bivector> for Bivector {
    type Output = Scalar;
    fn inner_product(self, b: Bivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
        }
    }
}

impl InnerProduct<Trivector> for Bivector {
    type Output = Vector;
    fn inner_product(self, b: Trivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
        }
    }
}

impl InnerProduct<Null> for Bivector {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: -a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: -a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl InnerProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl InnerProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: -a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: -a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: 0.0,
        }
    }
}

impl InnerProduct<Scalar> for Trivector {
    type Output = Trivector;
    fn inner_product(self, b: Scalar) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Vector> for Trivector {
    type Output = Bivector;
    fn inner_product(self, b: Vector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl InnerProduct<Bivector> for Trivector {
    type Output = Vector;
    fn inner_product(self, b: Bivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
        }
    }
}

impl InnerProduct<Trivector> for Trivector {
    type Output = Scalar;
    fn inner_product(self, b: Trivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.e012 * b.e012,
        }
    }
}

impl InnerProduct<Null> for Trivector {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl InnerProduct<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Multivector> for Trivector {
    type Output = Multivector;
    fn inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Scalar> for Null {
    type Output = Null;
    fn inner_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<Vector> for Null {
    type Output = Null;
    fn inner_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<Bivector> for Null {
    type Output = Null;
    fn inner_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<Trivector> for Null {
    type Output = Null;
    fn inner_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<Null> for Null {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for Null {
    type Output = Null;
    fn inner_product(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<EvenMultivector> for Null {
    type Output = Null;
    fn inner_product(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<Multivector> for Null {
    type Output = Null;
    fn inner_product(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn inner_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl InnerProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn inner_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 - a.e012 * b.e01,
            e012: 0.0,
        }
    }
}

impl InnerProduct<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl InnerProduct<Null> for OddMultivector {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e01: a.e2 * b.e012 + a.e012 * b.e2,
            e20: a.e1 * b.e012 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e012 * b.e0,
        }
    }
}

impl InnerProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn inner_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e012 * b.e01,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e012 * b.e01,
            e01: a.e2 * b.e012 + a.e012 * b.e2,
            e20: a.e1 * b.e012 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e012 * b.e0,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl InnerProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn inner_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2,
            e1: a.s * b.e1 - a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.s * b.e2 + a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl InnerProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl InnerProduct<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn inner_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<Null> for EvenMultivector {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn inner_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: a.s * b.e2 - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn inner_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
        }
    }
}

impl InnerProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: a.s * b.e2 - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn inner_product(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Vector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2,
            e1: a.s * b.e1 - a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.s * b.e2 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: 0.0,
        }
    }
}

impl InnerProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 - a.e012 * b.e01,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: 0.0,
        }
    }
}

impl InnerProduct<Trivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<Null> for Multivector {
    type Output = Null;
    fn inner_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl InnerProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.s * b.e0 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2,
            e2: a.s * b.e2 - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e2 * b.e012 + a.e012 * b.e2,
            e20: a.e1 * b.e012 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e012 * b.e0,
            e012: a.s * b.e012,
        }
    }
}

impl InnerProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 - a.e012 * b.e12,
            e1: a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e012 * b.e20,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e012 * b.e01,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl InnerProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn inner_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s + a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12 - a.e012 * b.e012,
            e0: a.s * b.e0 + a.e0 * b.s - a.e1 * b.e01 + a.e2 * b.e20 + a.e01 * b.e1 - a.e20 * b.e2 - a.e12 * b.e012 - a.e012 * b.e12,
            e1: a.s * b.e1 + a.e0 * b.e01 + a.e1 * b.s - a.e2 * b.e12 - a.e01 * b.e0 - a.e20 * b.e012 + a.e12 * b.e2 - a.e012 * b.e20,
            e2: a.s * b.e2 - a.e0 * b.e20 + a.e1 * b.e12 + a.e2 * b.s - a.e01 * b.e012 + a.e20 * b.e0 - a.e12 * b.e1 - a.e012 * b.e01,
            e01: a.s * b.e01 + a.e2 * b.e012 + a.e01 * b.s + a.e012 * b.e2,
            e20: a.s * b.e20 + a.e1 * b.e012 + a.e20 * b.s + a.e012 * b.e1,
            e12: a.s * b.e12 + a.e0 * b.e012 + a.e12 * b.s + a.e012 * b.e0,
            e012: a.s * b.e012 + a.e012 * b.s,
        }
    }
}

impl OuterProduct<Scalar> for Scalar {
    type Output = Scalar;
    fn outer_product(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s,
        }
    }
}

impl OuterProduct<Vector> for Scalar {
    type Output = Vector;
    fn outer_product(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
        }
    }
}

impl OuterProduct<Bivector> for Scalar {
    type Output = Bivector;
    fn outer_product(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl OuterProduct<Trivector> for Scalar {
    type Output = Trivector;
    fn outer_product(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.s * b.e012,
        }
    }
}

impl OuterProduct<Null> for Scalar {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn outer_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.s * b.e012,
        }
    }
}

impl OuterProduct<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn outer_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl OuterProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn outer_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.s * b.e012,
        }
    }
}

impl OuterProduct<Scalar> for Vector {
    type Output = Vector;
    fn outer_product(self, b: Scalar) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
        }
    }
}

impl OuterProduct<Vector> for Vector {
    type Output = Bivector;
    fn outer_product(self, b: Vector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl OuterProduct<Bivector> for Vector {
    type Output = Trivector;
    fn outer_product(self, b: Bivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl OuterProduct<Trivector> for Vector {
    type Output = Null;
    fn outer_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Null> for Vector {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn outer_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl OuterProduct<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn outer_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl OuterProduct<Multivector> for Vector {
    type Output = Multivector;
    fn outer_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl OuterProduct<Scalar> for Bivector {
    type Output = Bivector;
    fn outer_product(self, b: Scalar) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl OuterProduct<Vector> for Bivector {
    type Output = Trivector;
    fn outer_product(self, b: Vector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<Bivector> for Bivector {
    type Output = Null;
    fn outer_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Trivector> for Bivector {
    type Output = Null;
    fn outer_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Null> for Bivector {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn outer_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl OuterProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn outer_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<Scalar> for Trivector {
    type Output = Trivector;
    fn outer_product(self, b: Scalar) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.s,
        }
    }
}

impl OuterProduct<Vector> for Trivector {
    type Output = Null;
    fn outer_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Bivector> for Trivector {
    type Output = Null;
    fn outer_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Trivector> for Trivector {
    type Output = Null;
    fn outer_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Null> for Trivector {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl OuterProduct<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn outer_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e012 * b.s,
        }
    }
}

impl OuterProduct<Multivector> for Trivector {
    type Output = Multivector;
    fn outer_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.e012 * b.s,
        }
    }
}

impl OuterProduct<Scalar> for Null {
    type Output = Null;
    fn outer_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Vector> for Null {
    type Output = Null;
    fn outer_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Bivector> for Null {
    type Output = Null;
    fn outer_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Trivector> for Null {
    type Output = Null;
    fn outer_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Null> for Null {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for Null {
    type Output = Null;
    fn outer_product(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<EvenMultivector> for Null {
    type Output = Null;
    fn outer_product(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Multivector> for Null {
    type Output = Null;
    fn outer_product(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn outer_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl OuterProduct<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl OuterProduct<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn outer_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl OuterProduct<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl OuterProduct<Null> for OddMultivector {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl OuterProduct<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn outer_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl OuterProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn outer_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl OuterProduct<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl OuterProduct<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn outer_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl OuterProduct<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn outer_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.s * b.e012,
        }
    }
}

impl OuterProduct<Null> for EvenMultivector {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn outer_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn outer_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
        }
    }
}

impl OuterProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn outer_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn outer_product(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl OuterProduct<Vector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl OuterProduct<Trivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: a.s * b.e012,
        }
    }
}

impl OuterProduct<Null> for Multivector {
    type Output = Null;
    fn outer_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl OuterProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl OuterProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl OuterProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn outer_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.s * b.e0 + a.e0 * b.s,
            e1: a.s * b.e1 + a.e1 * b.s,
            e2: a.s * b.e2 + a.e2 * b.s,
            e01: a.s * b.e01 + a.e0 * b.e1 - a.e1 * b.e0 + a.e01 * b.s,
            e20: a.s * b.e20 - a.e0 * b.e2 + a.e2 * b.e0 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e1 * b.e2 - a.e2 * b.e1 + a.e12 * b.s,
            e012: a.s * b.e012 + a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0 + a.e012 * b.s,
        }
    }
}

impl RegressiveProduct<Scalar> for Scalar {
    type Output = Null;
    fn regressive_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Vector> for Scalar {
    type Output = Null;
    fn regressive_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Bivector> for Scalar {
    type Output = Null;
    fn regressive_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Trivector> for Scalar {
    type Output = Scalar;
    fn regressive_product(self, b: Trivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.e012,
        }
    }
}

impl RegressiveProduct<Null> for Scalar {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Scalar {
    type Output = EvenMultivector;
    fn regressive_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Scalar {
    type Output = OddMultivector;
    fn regressive_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for Scalar {
    type Output = Multivector;
    fn regressive_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e012,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Vector {
    type Output = Null;
    fn regressive_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Vector> for Vector {
    type Output = Null;
    fn regressive_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Bivector> for Vector {
    type Output = Scalar;
    fn regressive_product(self, b: Bivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl RegressiveProduct<Trivector> for Vector {
    type Output = Vector;
    fn regressive_product(self, b: Trivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e012,
            e1: a.e1 * b.e012,
            e2: a.e2 * b.e012,
        }
    }
}

impl RegressiveProduct<Null> for Vector {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Vector {
    type Output = OddMultivector;
    fn regressive_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e012,
            e1: a.e1 * b.e012,
            e2: a.e2 * b.e012,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Vector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for Vector {
    type Output = Multivector;
    fn regressive_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
            e0: a.e0 * b.e012,
            e1: a.e1 * b.e012,
            e2: a.e2 * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Bivector {
    type Output = Null;
    fn regressive_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Vector> for Bivector {
    type Output = Scalar;
    fn regressive_product(self, b: Vector) -> Scalar {
        let a = self;
        Scalar {
            s: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl RegressiveProduct<Bivector> for Bivector {
    type Output = Vector;
    fn regressive_product(self, b: Bivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
        }
    }
}

impl RegressiveProduct<Trivector> for Bivector {
    type Output = Bivector;
    fn regressive_product(self, b: Trivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
        }
    }
}

impl RegressiveProduct<Null> for Bivector {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Bivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Bivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for Bivector {
    type Output = Multivector;
    fn regressive_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Trivector {
    type Output = Scalar;
    fn regressive_product(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.e012 * b.s,
        }
    }
}

impl RegressiveProduct<Vector> for Trivector {
    type Output = Vector;
    fn regressive_product(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e012 * b.e0,
            e1: a.e012 * b.e1,
            e2: a.e012 * b.e2,
        }
    }
}

impl RegressiveProduct<Bivector> for Trivector {
    type Output = Bivector;
    fn regressive_product(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
        }
    }
}

impl RegressiveProduct<Trivector> for Trivector {
    type Output = Trivector;
    fn regressive_product(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<Null> for Trivector {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Trivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e012 * b.e0,
            e1: a.e012 * b.e1,
            e2: a.e012 * b.e2,
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Trivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e012 * b.s,
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
        }
    }
}

impl RegressiveProduct<Multivector> for Trivector {
    type Output = Multivector;
    fn regressive_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e012 * b.s,
            e0: a.e012 * b.e0,
            e1: a.e012 * b.e1,
            e2: a.e012 * b.e2,
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<Scalar> for Null {
    type Output = Null;
    fn regressive_product(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Vector> for Null {
    type Output = Null;
    fn regressive_product(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Bivector> for Null {
    type Output = Null;
    fn regressive_product(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Trivector> for Null {
    type Output = Null;
    fn regressive_product(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Null> for Null {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Null {
    type Output = Null;
    fn regressive_product(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<EvenMultivector> for Null {
    type Output = Null;
    fn regressive_product(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Multivector> for Null {
    type Output = Null;
    fn regressive_product(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<Scalar> for OddMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e012 * b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RegressiveProduct<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e012 * b.e0,
            e1: a.e012 * b.e1,
            e2: a.e012 * b.e2,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Bivector> for OddMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
        }
    }
}

impl RegressiveProduct<Trivector> for OddMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e012,
            e1: a.e1 * b.e012,
            e2: a.e2 * b.e012,
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<Null> for OddMultivector {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e012 + a.e012 * b.e0,
            e1: a.e1 * b.e012 + a.e012 * b.e1,
            e2: a.e2 * b.e012 + a.e012 * b.e2,
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
        }
    }
}

impl RegressiveProduct<Multivector> for OddMultivector {
    type Output = Multivector;
    fn regressive_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
            e0: a.e0 * b.e012 + a.e012 * b.e0,
            e1: a.e1 * b.e012 + a.e012 * b.e1,
            e2: a.e2 * b.e012 + a.e012 * b.e2,
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<Scalar> for EvenMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Vector> for EvenMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl RegressiveProduct<Bivector> for EvenMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Trivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e012,
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
        }
    }
}

impl RegressiveProduct<Null> for EvenMultivector {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn regressive_product(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn regressive_product(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn regressive_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Scalar> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.e012 * b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Vector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
            e0: a.e012 * b.e0,
            e1: a.e012 * b.e1,
            e2: a.e012 * b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Bivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Trivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e012,
            e0: a.e0 * b.e012,
            e1: a.e1 * b.e012,
            e2: a.e2 * b.e012,
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<Null> for Multivector {
    type Output = Null;
    fn regressive_product(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl RegressiveProduct<OddMultivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
            e0: a.e0 * b.e012 + a.e012 * b.e0,
            e1: a.e1 * b.e012 + a.e012 * b.e1,
            e2: a.e2 * b.e012 + a.e012 * b.e2,
            e01: a.e01 * b.e012,
            e20: a.e20 * b.e012,
            e12: a.e12 * b.e012,
            e012: a.e012 * b.e012,
        }
    }
}

impl RegressiveProduct<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
            e0: -a.e01 * b.e20 + a.e20 * b.e01,
            e1: a.e01 * b.e12 - a.e12 * b.e01,
            e2: -a.e20 * b.e12 + a.e12 * b.e20,
            e01: a.e012 * b.e01,
            e20: a.e012 * b.e20,
            e12: a.e012 * b.e12,
            e012: 0.0,
        }
    }
}

impl RegressiveProduct<Multivector> for Multivector {
    type Output = Multivector;
    fn regressive_product(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e012 + a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0 + a.e012 * b.s,
            e0: a.e0 * b.e012 - a.e01 * b.e20 + a.e20 * b.e01 + a.e012 * b.e0,
            e1: a.e1 * b.e012 + a.e01 * b.e12 - a.e12 * b.e01 + a.e012 * b.e1,
            e2: a.e2 * b.e012 - a.e20 * b.e12 + a.e12 * b.e20 + a.e012 * b.e2,
            e01: a.e01 * b.e012 + a.e012 * b.e01,
            e20: a.e20 * b.e012 + a.e012 * b.e20,
            e12: a.e12 * b.e012 + a.e012 * b.e12,
            e012: a.e012 * b.e012,
        }
    }
}

impl Commutator<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn commutator(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Vector> for Scalar {
    type Output = OddMultivector;
    fn commutator(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn commutator(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Trivector> for Scalar {
    type Output = OddMultivector;
    fn commutator(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Null> for Scalar {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn commutator(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn commutator(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Multivector> for Scalar {
    type Output = Multivector;
    fn commutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Scalar> for Vector {
    type Output = OddMultivector;
    fn commutator(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Vector> for Vector {
    type Output = EvenMultivector;
    fn commutator(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl Commutator<Bivector> for Vector {
    type Output = OddMultivector;
    fn commutator(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: 0.0,
        }
    }
}

impl Commutator<Trivector> for Vector {
    type Output = EvenMultivector;
    fn commutator(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Null> for Vector {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn commutator(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl Commutator<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn commutator(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: 0.0,
        }
    }
}

impl Commutator<Multivector> for Vector {
    type Output = Multivector;
    fn commutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Vector> for Bivector {
    type Output = OddMultivector;
    fn commutator(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
        }
    }
}

impl Commutator<Trivector> for Bivector {
    type Output = OddMultivector;
    fn commutator(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Null> for Bivector {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn commutator(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn commutator(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
        }
    }
}

impl Commutator<Multivector> for Bivector {
    type Output = Multivector;
    fn commutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
            e012: 0.0,
        }
    }
}

impl Commutator<Scalar> for Trivector {
    type Output = OddMultivector;
    fn commutator(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Vector> for Trivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Bivector> for Trivector {
    type Output = OddMultivector;
    fn commutator(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Trivector> for Trivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Null> for Trivector {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn commutator(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn commutator(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Multivector> for Trivector {
    type Output = Multivector;
    fn commutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Scalar> for Null {
    type Output = Null;
    fn commutator(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<Vector> for Null {
    type Output = Null;
    fn commutator(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<Bivector> for Null {
    type Output = Null;
    fn commutator(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<Trivector> for Null {
    type Output = Null;
    fn commutator(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<Null> for Null {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for Null {
    type Output = Null;
    fn commutator(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<EvenMultivector> for Null {
    type Output = Null;
    fn commutator(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<Multivector> for Null {
    type Output = Null;
    fn commutator(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn commutator(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl Commutator<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn commutator(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: 0.0,
        }
    }
}

impl Commutator<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Null> for OddMultivector {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn commutator(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
        }
    }
}

impl Commutator<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn commutator(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e012: 0.0,
        }
    }
}

impl Commutator<Multivector> for OddMultivector {
    type Output = Multivector;
    fn commutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Commutator<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn commutator(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn commutator(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
        }
    }
}

impl Commutator<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn commutator(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Null> for EvenMultivector {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn commutator(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn commutator(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
        }
    }
}

impl Commutator<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn commutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
            e012: 0.0,
        }
    }
}

impl Commutator<Scalar> for Multivector {
    type Output = Multivector;
    fn commutator(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Vector> for Multivector {
    type Output = Multivector;
    fn commutator(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<Bivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
            e012: 0.0,
        }
    }
}

impl Commutator<Trivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Commutator<Null> for Multivector {
    type Output = Null;
    fn commutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Commutator<OddMultivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: a.e01 * b.e1 - a.e20 * b.e2,
            e1: -a.e01 * b.e0 + a.e12 * b.e2,
            e2: a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e0 * b.e1 - a.e1 * b.e0,
            e20: -a.e0 * b.e2 + a.e2 * b.e0,
            e12: a.e1 * b.e2 - a.e2 * b.e1,
            e012: 0.0,
        }
    }
}

impl Commutator<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: -a.e1 * b.e01 + a.e2 * b.e20,
            e1: a.e0 * b.e01 - a.e2 * b.e12,
            e2: -a.e0 * b.e20 + a.e1 * b.e12,
            e01: a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e01 * b.e20 - a.e20 * b.e01,
            e012: 0.0,
        }
    }
}

impl Commutator<Multivector> for Multivector {
    type Output = Multivector;
    fn commutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: -a.e1 * b.e01 + a.e2 * b.e20 + a.e01 * b.e1 - a.e20 * b.e2,
            e1: a.e0 * b.e01 - a.e2 * b.e12 - a.e01 * b.e0 + a.e12 * b.e2,
            e2: -a.e0 * b.e20 + a.e1 * b.e12 + a.e20 * b.e0 - a.e12 * b.e1,
            e01: a.e0 * b.e1 - a.e1 * b.e0 + a.e20 * b.e12 - a.e12 * b.e20,
            e20: -a.e0 * b.e2 + a.e2 * b.e0 - a.e01 * b.e12 + a.e12 * b.e01,
            e12: a.e1 * b.e2 - a.e2 * b.e1 + a.e01 * b.e20 - a.e20 * b.e01,
            e012: 0.0,
        }
    }
}

impl Anticommutator<Scalar> for Scalar {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Anticommutator<Vector> for Scalar {
    type Output = OddMultivector;
    fn anticommutator(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: 0.0,
        }
    }
}

impl Anticommutator<Bivector> for Scalar {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl Anticommutator<Trivector> for Scalar {
    type Output = OddMultivector;
    fn anticommutator(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.s * b.e012,
        }
    }
}

impl Anticommutator<Null> for Scalar {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for Scalar {
    type Output = OddMultivector;
    fn anticommutator(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.s * b.e012,
        }
    }
}

impl Anticommutator<EvenMultivector> for Scalar {
    type Output = EvenMultivector;
    fn anticommutator(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl Anticommutator<Multivector> for Scalar {
    type Output = Multivector;
    fn anticommutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.s * b.e012,
        }
    }
}

impl Anticommutator<Scalar> for Vector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: 0.0,
        }
    }
}

impl Anticommutator<Vector> for Vector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Anticommutator<Bivector> for Vector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl Anticommutator<Trivector> for Vector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl Anticommutator<Null> for Vector {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for Vector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl Anticommutator<EvenMultivector> for Vector {
    type Output = OddMultivector;
    fn anticommutator(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl Anticommutator<Multivector> for Vector {
    type Output = Multivector;
    fn anticommutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl Anticommutator<Scalar> for Bivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl Anticommutator<Vector> for Bivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<Bivector> for Bivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Anticommutator<Trivector> for Bivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: 0.0,
        }
    }
}

impl Anticommutator<Null> for Bivector {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for Bivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<EvenMultivector> for Bivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl Anticommutator<Multivector> for Bivector {
    type Output = Multivector;
    fn anticommutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<Scalar> for Trivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: a.e012 * b.s,
        }
    }
}

impl Anticommutator<Vector> for Trivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl Anticommutator<Bivector> for Trivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: 0.0,
        }
    }
}

impl Anticommutator<Trivector> for Trivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Anticommutator<Null> for Trivector {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for Trivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl Anticommutator<EvenMultivector> for Trivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: a.e012 * b.s,
        }
    }
}

impl Anticommutator<Multivector> for Trivector {
    type Output = Multivector;
    fn anticommutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: a.e012 * b.s,
        }
    }
}

impl Anticommutator<Scalar> for Null {
    type Output = Null;
    fn anticommutator(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<Vector> for Null {
    type Output = Null;
    fn anticommutator(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<Bivector> for Null {
    type Output = Null;
    fn anticommutator(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<Trivector> for Null {
    type Output = Null;
    fn anticommutator(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<Null> for Null {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for Null {
    type Output = Null;
    fn anticommutator(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<EvenMultivector> for Null {
    type Output = Null;
    fn anticommutator(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<Multivector> for Null {
    type Output = Null;
    fn anticommutator(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl Anticommutator<Vector> for OddMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
        }
    }
}

impl Anticommutator<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl Anticommutator<Trivector> for OddMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e012 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
        }
    }
}

impl Anticommutator<Null> for OddMultivector {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for OddMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e01: a.e2 * b.e012 + a.e012 * b.e2,
            e20: a.e1 * b.e012 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e012 * b.e0,
        }
    }
}

impl Anticommutator<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s - a.e012 * b.e12,
            e1: a.e1 * b.s - a.e012 * b.e20,
            e2: a.e2 * b.s - a.e012 * b.e01,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl Anticommutator<Multivector> for OddMultivector {
    type Output = Multivector;
    fn anticommutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.e0 * b.s - a.e012 * b.e12,
            e1: a.e1 * b.s - a.e012 * b.e20,
            e2: a.e2 * b.s - a.e012 * b.e01,
            e01: a.e2 * b.e012 + a.e012 * b.e2,
            e20: a.e1 * b.e012 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e012 * b.e0,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl Anticommutator<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
        }
    }
}

impl Anticommutator<Vector> for EvenMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
        }
    }
}

impl Anticommutator<Trivector> for EvenMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl Anticommutator<Null> for EvenMultivector {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for EvenMultivector {
    type Output = OddMultivector;
    fn anticommutator(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.s * b.e0 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e20 * b.e012,
            e2: a.s * b.e2 - a.e01 * b.e012,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn anticommutator(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
        }
    }
}

impl Anticommutator<Multivector> for EvenMultivector {
    type Output = Multivector;
    fn anticommutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.s * b.e0 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e20 * b.e012,
            e2: a.s * b.e2 - a.e01 * b.e012,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<Scalar> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s,
            e0: a.e0 * b.s,
            e1: a.e1 * b.s,
            e2: a.e2 * b.s,
            e01: a.e01 * b.s,
            e20: a.e20 * b.s,
            e12: a.e12 * b.s,
            e012: a.e012 * b.s,
        }
    }
}

impl Anticommutator<Vector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2,
            e0: a.s * b.e0,
            e1: a.s * b.e1,
            e2: a.s * b.e2,
            e01: a.e012 * b.e2,
            e20: a.e012 * b.e1,
            e12: a.e012 * b.e0,
            e012: a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<Bivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: -a.e012 * b.e12,
            e1: -a.e012 * b.e20,
            e2: -a.e012 * b.e01,
            e01: a.s * b.e01,
            e20: a.s * b.e20,
            e12: a.s * b.e12,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01,
        }
    }
}

impl Anticommutator<Trivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.e012 * b.e012,
            e0: -a.e12 * b.e012,
            e1: -a.e20 * b.e012,
            e2: -a.e01 * b.e012,
            e01: a.e2 * b.e012,
            e20: a.e1 * b.e012,
            e12: a.e0 * b.e012,
            e012: a.s * b.e012,
        }
    }
}

impl Anticommutator<Null> for Multivector {
    type Output = Null;
    fn anticommutator(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Anticommutator<OddMultivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e012 * b.e012,
            e0: a.s * b.e0 - a.e12 * b.e012,
            e1: a.s * b.e1 - a.e20 * b.e012,
            e2: a.s * b.e2 - a.e01 * b.e012,
            e01: a.e2 * b.e012 + a.e012 * b.e2,
            e20: a.e1 * b.e012 + a.e012 * b.e1,
            e12: a.e0 * b.e012 + a.e012 * b.e0,
            e012: a.s * b.e012 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0,
        }
    }
}

impl Anticommutator<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12,
            e0: a.e0 * b.s - a.e012 * b.e12,
            e1: a.e1 * b.s - a.e012 * b.e20,
            e2: a.e2 * b.s - a.e012 * b.e01,
            e01: a.s * b.e01 + a.e01 * b.s,
            e20: a.s * b.e20 + a.e20 * b.s,
            e12: a.s * b.e12 + a.e12 * b.s,
            e012: a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e012 * b.s,
        }
    }
}

impl Anticommutator<Multivector> for Multivector {
    type Output = Multivector;
    fn anticommutator(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s + a.e0 * b.e0 + a.e1 * b.e1 + a.e2 * b.e2 - a.e01 * b.e01 - a.e20 * b.e20 - a.e12 * b.e12 - a.e012 * b.e012,
            e0: a.s * b.e0 + a.e0 * b.s - a.e12 * b.e012 - a.e012 * b.e12,
            e1: a.s * b.e1 + a.e1 * b.s - a.e20 * b.e012 - a.e012 * b.e20,
            e2: a.s * b.e2 + a.e2 * b.s - a.e01 * b.e012 - a.e012 * b.e01,
            e01: a.s * b.e01 + a.e2 * b.e012 + a.e01 * b.s + a.e012 * b.e2,
            e20: a.s * b.e20 + a.e1 * b.e012 + a.e20 * b.s + a.e012 * b.e1,
            e12: a.s * b.e12 + a.e0 * b.e012 + a.e12 * b.s + a.e012 * b.e0,
            e012: a.s * b.e012 + a.e0 * b.e12 + a.e1 * b.e20 + a.e2 * b.e01 + a.e01 * b.e2 + a.e20 * b.e1 + a.e12 * b.e0 + a.e012 * b.s,
        }
    }
}

impl Transform<Scalar> for Scalar {
    type Output = Scalar;
    fn transform(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s,
        }
    }
}

impl Transform<Vector> for Scalar {
    type Output = Scalar;
    fn transform(self, b: Vector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2,
        }
    }
}

impl Transform<Bivector> for Scalar {
    type Output = Scalar;
    fn transform(self, b: Bivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
        }
    }
}

impl Transform<Trivector> for Scalar {
    type Output = Scalar;
    fn transform(self, b: Trivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.s * b.e012 * b.e012,
        }
    }
}

impl Transform<Null> for Scalar {
    type Output = Scalar;
    fn transform(self, b: Null) -> Scalar {
        let a = self;
        Scalar {
            s: 0.0,
        }
    }
}

impl Transform<OddMultivector> for Scalar {
    type Output = Scalar;
    fn transform(self, b: OddMultivector) -> Scalar {
        let a = self;
        Scalar {
            s: -a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2 - a.s * b.e012 * b.e012,
        }
    }
}

impl Transform<EvenMultivector> for Scalar {
    type Output = Scalar;
    fn transform(self, b: EvenMultivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
        }
    }
}

impl Transform<Multivector> for Scalar {
    type Output = Scalar;
    fn transform(self, b: Multivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s - a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 - a.s * b.e012 * b.e012,
        }
    }
}

impl Transform<Scalar> for Vector {
    type Output = Vector;
    fn transform(self, b: Scalar) -> Vector {
        let a = self;
        Vector {
            e0: -a.e0 * b.s * b.s,
            e1: -a.e1 * b.s * b.s,
            e2: -a.e2 * b.s * b.s,
        }
    }
}

impl Transform<Vector> for Vector {
    type Output = Vector;
    fn transform(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + 2.0 * a.e1 * b.e0 * b.e1 + 2.0 * a.e2 * b.e0 * b.e2,
            e1: 2.0 * a.e0 * b.e0 * b.e1 - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + 2.0 * a.e2 * b.e1 * b.e2,
            e2: 2.0 * a.e0 * b.e0 * b.e2 + 2.0 * a.e1 * b.e1 * b.e2 - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2,
        }
    }
}

impl Transform<Bivector> for Vector {
    type Output = Vector;
    fn transform(self, b: Bivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 - 2.0 * a.e1 * b.e20 * b.e12 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: -2.0 * a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.e01 * b.e12 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
        }
    }
}

impl Transform<Trivector> for Vector {
    type Output = Vector;
    fn transform(self, b: Trivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e012 * b.e012,
            e1: a.e1 * b.e012 * b.e012,
            e2: a.e2 * b.e012 * b.e012,
        }
    }
}

impl Transform<Null> for Vector {
    type Output = Vector;
    fn transform(self, b: Null) -> Vector {
        let a = self;
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl Transform<OddMultivector> for Vector {
    type Output = Vector;
    fn transform(self, b: OddMultivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + a.e0 * b.e012 * b.e012 + 2.0 * a.e1 * b.e0 * b.e1 - 2.0 * a.e1 * b.e2 * b.e012 + 2.0 * a.e2 * b.e0 * b.e2 + 2.0 * a.e2 * b.e1 * b.e012,
            e1: 2.0 * a.e0 * b.e0 * b.e1 + 2.0 * a.e0 * b.e2 * b.e012 - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + a.e1 * b.e012 * b.e012 - 2.0 * a.e2 * b.e0 * b.e012 + 2.0 * a.e2 * b.e1 * b.e2,
            e2: 2.0 * a.e0 * b.e0 * b.e2 - 2.0 * a.e0 * b.e1 * b.e012 + 2.0 * a.e1 * b.e0 * b.e012 + 2.0 * a.e1 * b.e1 * b.e2 - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2 + a.e2 * b.e012 * b.e012,
        }
    }
}

impl Transform<EvenMultivector> for Vector {
    type Output = Vector;
    fn transform(self, b: EvenMultivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e0 * b.s * b.s + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 - 2.0 * a.e1 * b.s * b.e01 - 2.0 * a.e1 * b.e20 * b.e12 + 2.0 * a.e2 * b.s * b.e20 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: 2.0 * a.e0 * b.s * b.e01 - 2.0 * a.e0 * b.e20 * b.e12 - a.e1 * b.s * b.s + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 - 2.0 * a.e2 * b.s * b.e12 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.s * b.e20 - 2.0 * a.e0 * b.e01 * b.e12 + 2.0 * a.e1 * b.s * b.e12 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.s * b.s - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
        }
    }
}

impl Transform<Multivector> for Vector {
    type Output = Vector;
    fn transform(self, b: Multivector) -> Vector {
        let a = self;
        Vector {
            e0: -a.e0 * b.s * b.s + a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 + a.e0 * b.e012 * b.e012 - 2.0 * a.e1 * b.s * b.e01 + 2.0 * a.e1 * b.e0 * b.e1 - 2.0 * a.e1 * b.e2 * b.e012 - 2.0 * a.e1 * b.e20 * b.e12 + 2.0 * a.e2 * b.s * b.e20 + 2.0 * a.e2 * b.e0 * b.e2 + 2.0 * a.e2 * b.e1 * b.e012 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: 2.0 * a.e0 * b.s * b.e01 + 2.0 * a.e0 * b.e0 * b.e1 + 2.0 * a.e0 * b.e2 * b.e012 - 2.0 * a.e0 * b.e20 * b.e12 - a.e1 * b.s * b.s - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 + a.e1 * b.e012 * b.e012 - 2.0 * a.e2 * b.s * b.e12 - 2.0 * a.e2 * b.e0 * b.e012 + 2.0 * a.e2 * b.e1 * b.e2 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.s * b.e20 + 2.0 * a.e0 * b.e0 * b.e2 - 2.0 * a.e0 * b.e1 * b.e012 - 2.0 * a.e0 * b.e01 * b.e12 + 2.0 * a.e1 * b.s * b.e12 + 2.0 * a.e1 * b.e0 * b.e012 + 2.0 * a.e1 * b.e1 * b.e2 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.s * b.s - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2 - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12 + a.e2 * b.e012 * b.e012,
        }
    }
}

impl Transform<Scalar> for Bivector {
    type Output = Bivector;
    fn transform(self, b: Scalar) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
        }
    }
}

impl Transform<Vector> for Bivector {
    type Output = Bivector;
    fn transform(self, b: Vector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 - 2.0 * a.e20 * b.e1 * b.e2 - 2.0 * a.e12 * b.e0 * b.e2,
            e20: -2.0 * a.e01 * b.e1 * b.e2 + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - 2.0 * a.e12 * b.e0 * b.e1,
            e12: -2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e20 * b.e0 * b.e1 - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2,
        }
    }
}

impl Transform<Bivector> for Bivector {
    type Output = Bivector;
    fn transform(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.e01 * b.e20 - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.e20 * b.e12 - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Transform<Trivector> for Bivector {
    type Output = Bivector;
    fn transform(self, b: Trivector) -> Bivector {
        let a = self;
        Bivector {
            e01: -a.e01 * b.e012 * b.e012,
            e20: -a.e20 * b.e012 * b.e012,
            e12: -a.e12 * b.e012 * b.e012,
        }
    }
}

impl Transform<Null> for Bivector {
    type Output = Bivector;
    fn transform(self, b: Null) -> Bivector {
        let a = self;
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Transform<OddMultivector> for Bivector {
    type Output = Bivector;
    fn transform(self, b: OddMultivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 - a.e01 * b.e012 * b.e012 - 2.0 * a.e20 * b.e0 * b.e012 - 2.0 * a.e20 * b.e1 * b.e2 - 2.0 * a.e12 * b.e0 * b.e2 + 2.0 * a.e12 * b.e1 * b.e012,
            e20: 2.0 * a.e01 * b.e0 * b.e012 - 2.0 * a.e01 * b.e1 * b.e2 + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - a.e20 * b.e012 * b.e012 - 2.0 * a.e12 * b.e0 * b.e1 - 2.0 * a.e12 * b.e2 * b.e012,
            e12: -2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e01 * b.e1 * b.e012 - 2.0 * a.e20 * b.e0 * b.e1 + 2.0 * a.e20 * b.e2 * b.e012 - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2 - a.e12 * b.e012 * b.e012,
        }
    }
}

impl Transform<EvenMultivector> for Bivector {
    type Output = Bivector;
    fn transform(self, b: EvenMultivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s * b.s + a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 - 2.0 * a.e20 * b.s * b.e12 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.s * b.e20 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.s * b.e12 + 2.0 * a.e01 * b.e01 * b.e20 + a.e20 * b.s * b.s - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 - 2.0 * a.e12 * b.s * b.e01 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: -2.0 * a.e01 * b.s * b.e20 + 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.s * b.e01 + 2.0 * a.e20 * b.e20 * b.e12 + a.e12 * b.s * b.s - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Transform<Multivector> for Bivector {
    type Output = Bivector;
    fn transform(self, b: Multivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s * b.s + a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 + a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 - a.e01 * b.e012 * b.e012 - 2.0 * a.e20 * b.s * b.e12 - 2.0 * a.e20 * b.e0 * b.e012 - 2.0 * a.e20 * b.e1 * b.e2 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.s * b.e20 - 2.0 * a.e12 * b.e0 * b.e2 + 2.0 * a.e12 * b.e1 * b.e012 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.s * b.e12 + 2.0 * a.e01 * b.e0 * b.e012 - 2.0 * a.e01 * b.e1 * b.e2 + 2.0 * a.e01 * b.e01 * b.e20 + a.e20 * b.s * b.s + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 - a.e20 * b.e012 * b.e012 - 2.0 * a.e12 * b.s * b.e01 - 2.0 * a.e12 * b.e0 * b.e1 - 2.0 * a.e12 * b.e2 * b.e012 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: -2.0 * a.e01 * b.s * b.e20 - 2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e01 * b.e1 * b.e012 + 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.s * b.e01 - 2.0 * a.e20 * b.e0 * b.e1 + 2.0 * a.e20 * b.e2 * b.e012 + 2.0 * a.e20 * b.e20 * b.e12 + a.e12 * b.s * b.s - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2 - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12 - a.e12 * b.e012 * b.e012,
        }
    }
}

impl Transform<Scalar> for Trivector {
    type Output = Trivector;
    fn transform(self, b: Scalar) -> Trivector {
        let a = self;
        Trivector {
            e012: -a.e012 * b.s * b.s,
        }
    }
}

impl Transform<Vector> for Trivector {
    type Output = Trivector;
    fn transform(self, b: Vector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2,
        }
    }
}

impl Transform<Bivector> for Trivector {
    type Output = Trivector;
    fn transform(self, b: Bivector) -> Trivector {
        let a = self;
        Trivector {
            e012: -a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12,
        }
    }
}

impl Transform<Trivector> for Trivector {
    type Output = Trivector;
    fn transform(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<Null> for Trivector {
    type Output = Trivector;
    fn transform(self, b: Null) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Transform<OddMultivector> for Trivector {
    type Output = Trivector;
    fn transform(self, b: OddMultivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2 + a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<EvenMultivector> for Trivector {
    type Output = Trivector;
    fn transform(self, b: EvenMultivector) -> Trivector {
        let a = self;
        Trivector {
            e012: -a.e012 * b.s * b.s - a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12,
        }
    }
}

impl Transform<Multivector> for Trivector {
    type Output = Trivector;
    fn transform(self, b: Multivector) -> Trivector {
        let a = self;
        Trivector {
            e012: -a.e012 * b.s * b.s + a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2 - a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12 + a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<Scalar> for Null {
    type Output = Null;
    fn transform(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Transform<Vector> for Null {
    type Output = Null;
    fn transform(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Transform<Bivector> for Null {
    type Output = Null;
    fn transform(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Transform<Trivector> for Null {
    type Output = Null;
    fn transform(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Transform<Null> for Null {
    type Output = Null;
    fn transform(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Transform<OddMultivector> for Null {
    type Output = Null;
    fn transform(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Transform<EvenMultivector> for Null {
    type Output = Null;
    fn transform(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Transform<Multivector> for Null {
    type Output = Null;
    fn transform(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl Transform<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e0 * b.s * b.s,
            e1: -a.e1 * b.s * b.s,
            e2: -a.e2 * b.s * b.s,
            e012: -a.e012 * b.s * b.s,
        }
    }
}

impl Transform<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + 2.0 * a.e1 * b.e0 * b.e1 + 2.0 * a.e2 * b.e0 * b.e2,
            e1: 2.0 * a.e0 * b.e0 * b.e1 - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + 2.0 * a.e2 * b.e1 * b.e2,
            e2: 2.0 * a.e0 * b.e0 * b.e2 + 2.0 * a.e1 * b.e1 * b.e2 - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2,
            e012: a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2,
        }
    }
}

impl Transform<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 - 2.0 * a.e1 * b.e20 * b.e12 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: -2.0 * a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.e01 * b.e12 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e012: -a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12,
        }
    }
}

impl Transform<Trivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e012 * b.e012,
            e1: a.e1 * b.e012 * b.e012,
            e2: a.e2 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<Null> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Transform<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + a.e0 * b.e012 * b.e012 + 2.0 * a.e1 * b.e0 * b.e1 - 2.0 * a.e1 * b.e2 * b.e012 + 2.0 * a.e2 * b.e0 * b.e2 + 2.0 * a.e2 * b.e1 * b.e012,
            e1: 2.0 * a.e0 * b.e0 * b.e1 + 2.0 * a.e0 * b.e2 * b.e012 - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + a.e1 * b.e012 * b.e012 - 2.0 * a.e2 * b.e0 * b.e012 + 2.0 * a.e2 * b.e1 * b.e2,
            e2: 2.0 * a.e0 * b.e0 * b.e2 - 2.0 * a.e0 * b.e1 * b.e012 + 2.0 * a.e1 * b.e0 * b.e012 + 2.0 * a.e1 * b.e1 * b.e2 - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2 + a.e2 * b.e012 * b.e012,
            e012: a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2 + a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e0 * b.s * b.s + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 - 2.0 * a.e1 * b.s * b.e01 - 2.0 * a.e1 * b.e20 * b.e12 + 2.0 * a.e2 * b.s * b.e20 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: 2.0 * a.e0 * b.s * b.e01 - 2.0 * a.e0 * b.e20 * b.e12 - a.e1 * b.s * b.s + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 - 2.0 * a.e2 * b.s * b.e12 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.s * b.e20 - 2.0 * a.e0 * b.e01 * b.e12 + 2.0 * a.e1 * b.s * b.e12 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.s * b.s - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e012: -a.e012 * b.s * b.s - a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12,
        }
    }
}

impl Transform<Multivector> for OddMultivector {
    type Output = OddMultivector;
    fn transform(self, b: Multivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: -a.e0 * b.s * b.s + a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 + a.e0 * b.e012 * b.e012 - 2.0 * a.e1 * b.s * b.e01 + 2.0 * a.e1 * b.e0 * b.e1 - 2.0 * a.e1 * b.e2 * b.e012 - 2.0 * a.e1 * b.e20 * b.e12 + 2.0 * a.e2 * b.s * b.e20 + 2.0 * a.e2 * b.e0 * b.e2 + 2.0 * a.e2 * b.e1 * b.e012 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: 2.0 * a.e0 * b.s * b.e01 + 2.0 * a.e0 * b.e0 * b.e1 + 2.0 * a.e0 * b.e2 * b.e012 - 2.0 * a.e0 * b.e20 * b.e12 - a.e1 * b.s * b.s - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 + a.e1 * b.e012 * b.e012 - 2.0 * a.e2 * b.s * b.e12 - 2.0 * a.e2 * b.e0 * b.e012 + 2.0 * a.e2 * b.e1 * b.e2 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.s * b.e20 + 2.0 * a.e0 * b.e0 * b.e2 - 2.0 * a.e0 * b.e1 * b.e012 - 2.0 * a.e0 * b.e01 * b.e12 + 2.0 * a.e1 * b.s * b.e12 + 2.0 * a.e1 * b.e0 * b.e012 + 2.0 * a.e1 * b.e1 * b.e2 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.s * b.s - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2 - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12 + a.e2 * b.e012 * b.e012,
            e012: -a.e012 * b.s * b.s + a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2 - a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12 + a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s,
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
        }
    }
}

impl Transform<Vector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2,
            e01: a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 - 2.0 * a.e20 * b.e1 * b.e2 - 2.0 * a.e12 * b.e0 * b.e2,
            e20: -2.0 * a.e01 * b.e1 * b.e2 + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - 2.0 * a.e12 * b.e0 * b.e1,
            e12: -2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e20 * b.e0 * b.e1 - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2,
        }
    }
}

impl Transform<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e01: a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.e01 * b.e20 - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.e20 * b.e12 - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Transform<Trivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.s * b.e012 * b.e012,
            e01: -a.e01 * b.e012 * b.e012,
            e20: -a.e20 * b.e012 * b.e012,
            e12: -a.e12 * b.e012 * b.e012,
        }
    }
}

impl Transform<Null> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Transform<OddMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: -a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2 - a.s * b.e012 * b.e012,
            e01: a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 - a.e01 * b.e012 * b.e012 - 2.0 * a.e20 * b.e0 * b.e012 - 2.0 * a.e20 * b.e1 * b.e2 - 2.0 * a.e12 * b.e0 * b.e2 + 2.0 * a.e12 * b.e1 * b.e012,
            e20: 2.0 * a.e01 * b.e0 * b.e012 - 2.0 * a.e01 * b.e1 * b.e2 + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - a.e20 * b.e012 * b.e012 - 2.0 * a.e12 * b.e0 * b.e1 - 2.0 * a.e12 * b.e2 * b.e012,
            e12: -2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e01 * b.e1 * b.e012 - 2.0 * a.e20 * b.e0 * b.e1 + 2.0 * a.e20 * b.e2 * b.e012 - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2 - a.e12 * b.e012 * b.e012,
        }
    }
}

impl Transform<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e01: a.e01 * b.s * b.s + a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 - 2.0 * a.e20 * b.s * b.e12 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.s * b.e20 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.s * b.e12 + 2.0 * a.e01 * b.e01 * b.e20 + a.e20 * b.s * b.s - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 - 2.0 * a.e12 * b.s * b.e01 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: -2.0 * a.e01 * b.s * b.e20 + 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.s * b.e01 + 2.0 * a.e20 * b.e20 * b.e12 + a.e12 * b.s * b.s - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Transform<Multivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn transform(self, b: Multivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s - a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 - a.s * b.e012 * b.e012,
            e01: a.e01 * b.s * b.s + a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 + a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 - a.e01 * b.e012 * b.e012 - 2.0 * a.e20 * b.s * b.e12 - 2.0 * a.e20 * b.e0 * b.e012 - 2.0 * a.e20 * b.e1 * b.e2 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.s * b.e20 - 2.0 * a.e12 * b.e0 * b.e2 + 2.0 * a.e12 * b.e1 * b.e012 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.s * b.e12 + 2.0 * a.e01 * b.e0 * b.e012 - 2.0 * a.e01 * b.e1 * b.e2 + 2.0 * a.e01 * b.e01 * b.e20 + a.e20 * b.s * b.s + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 - a.e20 * b.e012 * b.e012 - 2.0 * a.e12 * b.s * b.e01 - 2.0 * a.e12 * b.e0 * b.e1 - 2.0 * a.e12 * b.e2 * b.e012 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: -2.0 * a.e01 * b.s * b.e20 - 2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e01 * b.e1 * b.e012 + 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.s * b.e01 - 2.0 * a.e20 * b.e0 * b.e1 + 2.0 * a.e20 * b.e2 * b.e012 + 2.0 * a.e20 * b.e20 * b.e12 + a.e12 * b.s * b.s - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2 - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12 - a.e12 * b.e012 * b.e012,
        }
    }
}

impl Transform<Scalar> for Multivector {
    type Output = Multivector;
    fn transform(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s,
            e0: -a.e0 * b.s * b.s,
            e1: -a.e1 * b.s * b.s,
            e2: -a.e2 * b.s * b.s,
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
            e012: -a.e012 * b.s * b.s,
        }
    }
}

impl Transform<Vector> for Multivector {
    type Output = Multivector;
    fn transform(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2,
            e0: a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + 2.0 * a.e1 * b.e0 * b.e1 + 2.0 * a.e2 * b.e0 * b.e2,
            e1: 2.0 * a.e0 * b.e0 * b.e1 - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + 2.0 * a.e2 * b.e1 * b.e2,
            e2: 2.0 * a.e0 * b.e0 * b.e2 + 2.0 * a.e1 * b.e1 * b.e2 - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2,
            e01: a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 - 2.0 * a.e20 * b.e1 * b.e2 - 2.0 * a.e12 * b.e0 * b.e2,
            e20: -2.0 * a.e01 * b.e1 * b.e2 + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - 2.0 * a.e12 * b.e0 * b.e1,
            e12: -2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e20 * b.e0 * b.e1 - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2,
            e012: a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2,
        }
    }
}

impl Transform<Bivector> for Multivector {
    type Output = Multivector;
    fn transform(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 - 2.0 * a.e1 * b.e20 * b.e12 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: -2.0 * a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.e01 * b.e12 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e01: a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.e01 * b.e20 - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.e20 * b.e12 - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12,
            e012: -a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12,
        }
    }
}

impl Transform<Trivector> for Multivector {
    type Output = Multivector;
    fn transform(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.s * b.e012 * b.e012,
            e0: a.e0 * b.e012 * b.e012,
            e1: a.e1 * b.e012 * b.e012,
            e2: a.e2 * b.e012 * b.e012,
            e01: -a.e01 * b.e012 * b.e012,
            e20: -a.e20 * b.e012 * b.e012,
            e12: -a.e12 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<Null> for Multivector {
    type Output = Multivector;
    fn transform(self, b: Null) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Transform<OddMultivector> for Multivector {
    type Output = Multivector;
    fn transform(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: -a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2 - a.s * b.e012 * b.e012,
            e0: a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + a.e0 * b.e012 * b.e012 + 2.0 * a.e1 * b.e0 * b.e1 - 2.0 * a.e1 * b.e2 * b.e012 + 2.0 * a.e2 * b.e0 * b.e2 + 2.0 * a.e2 * b.e1 * b.e012,
            e1: 2.0 * a.e0 * b.e0 * b.e1 + 2.0 * a.e0 * b.e2 * b.e012 - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + a.e1 * b.e012 * b.e012 - 2.0 * a.e2 * b.e0 * b.e012 + 2.0 * a.e2 * b.e1 * b.e2,
            e2: 2.0 * a.e0 * b.e0 * b.e2 - 2.0 * a.e0 * b.e1 * b.e012 + 2.0 * a.e1 * b.e0 * b.e012 + 2.0 * a.e1 * b.e1 * b.e2 - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2 + a.e2 * b.e012 * b.e012,
            e01: a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 - a.e01 * b.e012 * b.e012 - 2.0 * a.e20 * b.e0 * b.e012 - 2.0 * a.e20 * b.e1 * b.e2 - 2.0 * a.e12 * b.e0 * b.e2 + 2.0 * a.e12 * b.e1 * b.e012,
            e20: 2.0 * a.e01 * b.e0 * b.e012 - 2.0 * a.e01 * b.e1 * b.e2 + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - a.e20 * b.e012 * b.e012 - 2.0 * a.e12 * b.e0 * b.e1 - 2.0 * a.e12 * b.e2 * b.e012,
            e12: -2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e01 * b.e1 * b.e012 - 2.0 * a.e20 * b.e0 * b.e1 + 2.0 * a.e20 * b.e2 * b.e012 - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2 - a.e12 * b.e012 * b.e012,
            e012: a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2 + a.e012 * b.e012 * b.e012,
        }
    }
}

impl Transform<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn transform(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e0: -a.e0 * b.s * b.s + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 - 2.0 * a.e1 * b.s * b.e01 - 2.0 * a.e1 * b.e20 * b.e12 + 2.0 * a.e2 * b.s * b.e20 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: 2.0 * a.e0 * b.s * b.e01 - 2.0 * a.e0 * b.e20 * b.e12 - a.e1 * b.s * b.s + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 - 2.0 * a.e2 * b.s * b.e12 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.s * b.e20 - 2.0 * a.e0 * b.e01 * b.e12 + 2.0 * a.e1 * b.s * b.e12 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.s * b.s - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e01: a.e01 * b.s * b.s + a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 - 2.0 * a.e20 * b.s * b.e12 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.s * b.e20 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.s * b.e12 + 2.0 * a.e01 * b.e01 * b.e20 + a.e20 * b.s * b.s - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 - 2.0 * a.e12 * b.s * b.e01 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: -2.0 * a.e01 * b.s * b.e20 + 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.s * b.e01 + 2.0 * a.e20 * b.e20 * b.e12 + a.e12 * b.s * b.s - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12,
            e012: -a.e012 * b.s * b.s - a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12,
        }
    }
}

impl Transform<Multivector> for Multivector {
    type Output = Multivector;
    fn transform(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s - a.s * b.e0 * b.e0 - a.s * b.e1 * b.e1 - a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 - a.s * b.e012 * b.e012,
            e0: -a.e0 * b.s * b.s + a.e0 * b.e0 * b.e0 - a.e0 * b.e1 * b.e1 - a.e0 * b.e2 * b.e2 + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e0 * b.e12 * b.e12 + a.e0 * b.e012 * b.e012 - 2.0 * a.e1 * b.s * b.e01 + 2.0 * a.e1 * b.e0 * b.e1 - 2.0 * a.e1 * b.e2 * b.e012 - 2.0 * a.e1 * b.e20 * b.e12 + 2.0 * a.e2 * b.s * b.e20 + 2.0 * a.e2 * b.e0 * b.e2 + 2.0 * a.e2 * b.e1 * b.e012 - 2.0 * a.e2 * b.e01 * b.e12,
            e1: 2.0 * a.e0 * b.s * b.e01 + 2.0 * a.e0 * b.e0 * b.e1 + 2.0 * a.e0 * b.e2 * b.e012 - 2.0 * a.e0 * b.e20 * b.e12 - a.e1 * b.s * b.s - a.e1 * b.e0 * b.e0 + a.e1 * b.e1 * b.e1 - a.e1 * b.e2 * b.e2 + a.e1 * b.e01 * b.e01 - a.e1 * b.e20 * b.e20 + a.e1 * b.e12 * b.e12 + a.e1 * b.e012 * b.e012 - 2.0 * a.e2 * b.s * b.e12 - 2.0 * a.e2 * b.e0 * b.e012 + 2.0 * a.e2 * b.e1 * b.e2 - 2.0 * a.e2 * b.e01 * b.e20,
            e2: -2.0 * a.e0 * b.s * b.e20 + 2.0 * a.e0 * b.e0 * b.e2 - 2.0 * a.e0 * b.e1 * b.e012 - 2.0 * a.e0 * b.e01 * b.e12 + 2.0 * a.e1 * b.s * b.e12 + 2.0 * a.e1 * b.e0 * b.e012 + 2.0 * a.e1 * b.e1 * b.e2 - 2.0 * a.e1 * b.e01 * b.e20 - a.e2 * b.s * b.s - a.e2 * b.e0 * b.e0 - a.e2 * b.e1 * b.e1 + a.e2 * b.e2 * b.e2 - a.e2 * b.e01 * b.e01 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12 + a.e2 * b.e012 * b.e012,
            e01: a.e01 * b.s * b.s + a.e01 * b.e0 * b.e0 + a.e01 * b.e1 * b.e1 - a.e01 * b.e2 * b.e2 + a.e01 * b.e01 * b.e01 - a.e01 * b.e20 * b.e20 - a.e01 * b.e12 * b.e12 - a.e01 * b.e012 * b.e012 - 2.0 * a.e20 * b.s * b.e12 - 2.0 * a.e20 * b.e0 * b.e012 - 2.0 * a.e20 * b.e1 * b.e2 + 2.0 * a.e20 * b.e01 * b.e20 + 2.0 * a.e12 * b.s * b.e20 - 2.0 * a.e12 * b.e0 * b.e2 + 2.0 * a.e12 * b.e1 * b.e012 + 2.0 * a.e12 * b.e01 * b.e12,
            e20: 2.0 * a.e01 * b.s * b.e12 + 2.0 * a.e01 * b.e0 * b.e012 - 2.0 * a.e01 * b.e1 * b.e2 + 2.0 * a.e01 * b.e01 * b.e20 + a.e20 * b.s * b.s + a.e20 * b.e0 * b.e0 - a.e20 * b.e1 * b.e1 + a.e20 * b.e2 * b.e2 - a.e20 * b.e01 * b.e01 + a.e20 * b.e20 * b.e20 - a.e20 * b.e12 * b.e12 - a.e20 * b.e012 * b.e012 - 2.0 * a.e12 * b.s * b.e01 - 2.0 * a.e12 * b.e0 * b.e1 - 2.0 * a.e12 * b.e2 * b.e012 + 2.0 * a.e12 * b.e20 * b.e12,
            e12: -2.0 * a.e01 * b.s * b.e20 - 2.0 * a.e01 * b.e0 * b.e2 - 2.0 * a.e01 * b.e1 * b.e012 + 2.0 * a.e01 * b.e01 * b.e12 + 2.0 * a.e20 * b.s * b.e01 - 2.0 * a.e20 * b.e0 * b.e1 + 2.0 * a.e20 * b.e2 * b.e012 + 2.0 * a.e20 * b.e20 * b.e12 + a.e12 * b.s * b.s - a.e12 * b.e0 * b.e0 + a.e12 * b.e1 * b.e1 + a.e12 * b.e2 * b.e2 - a.e12 * b.e01 * b.e01 - a.e12 * b.e20 * b.e20 + a.e12 * b.e12 * b.e12 - a.e12 * b.e012 * b.e012,
            e012: -a.e012 * b.s * b.s + a.e012 * b.e0 * b.e0 + a.e012 * b.e1 * b.e1 + a.e012 * b.e2 * b.e2 - a.e012 * b.e01 * b.e01 - a.e012 * b.e20 * b.e20 - a.e012 * b.e12 * b.e12 + a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<Scalar> for Scalar {
    type Output = Scalar;
    fn project(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s,
        }
    }
}

impl Project<Vector> for Scalar {
    type Output = Scalar;
    fn project(self, b: Vector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2,
        }
    }
}

impl Project<Bivector> for Scalar {
    type Output = Scalar;
    fn project(self, b: Bivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
        }
    }
}

impl Project<Trivector> for Scalar {
    type Output = Scalar;
    fn project(self, b: Trivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.e012 * b.e012,
        }
    }
}

impl Project<Null> for Scalar {
    type Output = Scalar;
    fn project(self, b: Null) -> Scalar {
        let a = self;
        Scalar {
            s: 0.0,
        }
    }
}

impl Project<OddMultivector> for Scalar {
    type Output = Scalar;
    fn project(self, b: OddMultivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e012 * b.e012,
        }
    }
}

impl Project<EvenMultivector> for Scalar {
    type Output = Scalar;
    fn project(self, b: EvenMultivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
        }
    }
}

impl Project<Multivector> for Scalar {
    type Output = Scalar;
    fn project(self, b: Multivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s + a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 + a.s * b.e012 * b.e012,
        }
    }
}

impl Project<Scalar> for Vector {
    type Output = Null;
    fn project(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Project<Vector> for Vector {
    type Output = Vector;
    fn project(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e0 * b.e0 + a.e1 * b.e0 * b.e1 + a.e2 * b.e0 * b.e2,
            e1: a.e0 * b.e0 * b.e1 + a.e1 * b.e1 * b.e1 + a.e2 * b.e1 * b.e2,
            e2: a.e0 * b.e0 * b.e2 + a.e1 * b.e1 * b.e2 + a.e2 * b.e2 * b.e2,
        }
    }
}

impl Project<Bivector> for Vector {
    type Output = Vector;
    fn project(self, b: Bivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e1 * b.e20 * b.e12 - a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 - a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e01 * b.e12 - a.e1 * b.e01 * b.e20 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
        }
    }
}

impl Project<Trivector> for Vector {
    type Output = Vector;
    fn project(self, b: Trivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e012 * b.e012,
            e1: a.e1 * b.e012 * b.e012,
            e2: a.e2 * b.e012 * b.e012,
        }
    }
}

impl Project<Null> for Vector {
    type Output = Vector;
    fn project(self, b: Null) -> Vector {
        let a = self;
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl Project<OddMultivector> for Vector {
    type Output = Vector;
    fn project(self, b: OddMultivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e0 * b.e0 + a.e0 * b.e012 * b.e012 + a.e1 * b.e0 * b.e1 + a.e2 * b.e0 * b.e2,
            e1: a.e0 * b.e0 * b.e1 + a.e1 * b.e1 * b.e1 + a.e1 * b.e012 * b.e012 + a.e2 * b.e1 * b.e2,
            e2: a.e0 * b.e0 * b.e2 + a.e1 * b.e1 * b.e2 + a.e2 * b.e2 * b.e2 + a.e2 * b.e012 * b.e012,
        }
    }
}

impl Project<EvenMultivector> for Vector {
    type Output = Vector;
    fn project(self, b: EvenMultivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e1 * b.e20 * b.e12 - a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 - a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e01 * b.e12 - a.e1 * b.e01 * b.e20 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
        }
    }
}

impl Project<Multivector> for Vector {
    type Output = Vector;
    fn project(self, b: Multivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e0 * b.e0 + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 + a.e0 * b.e012 * b.e012 + a.e1 * b.e0 * b.e1 - a.e1 * b.e20 * b.e12 + a.e2 * b.e0 * b.e2 - a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e0 * b.e1 - a.e0 * b.e20 * b.e12 + a.e1 * b.e1 * b.e1 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 + a.e1 * b.e012 * b.e012 + a.e2 * b.e1 * b.e2 - a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e0 * b.e2 - a.e0 * b.e01 * b.e12 + a.e1 * b.e1 * b.e2 - a.e1 * b.e01 * b.e20 + a.e2 * b.e2 * b.e2 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12 + a.e2 * b.e012 * b.e012,
        }
    }
}

impl Project<Scalar> for Bivector {
    type Output = Null;
    fn project(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Project<Vector> for Bivector {
    type Output = Null;
    fn project(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Bivector> for Bivector {
    type Output = Bivector;
    fn project(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e01 * b.e01 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Project<Trivector> for Bivector {
    type Output = Bivector;
    fn project(self, b: Trivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e012 * b.e012,
            e20: a.e20 * b.e012 * b.e012,
            e12: a.e12 * b.e012 * b.e012,
        }
    }
}

impl Project<Null> for Bivector {
    type Output = Bivector;
    fn project(self, b: Null) -> Bivector {
        let a = self;
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Project<OddMultivector> for Bivector {
    type Output = Bivector;
    fn project(self, b: OddMultivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e012 * b.e012,
            e20: a.e20 * b.e012 * b.e012,
            e12: a.e12 * b.e012 * b.e012,
        }
    }
}

impl Project<EvenMultivector> for Bivector {
    type Output = Bivector;
    fn project(self, b: EvenMultivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e01 * b.e01 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Project<Multivector> for Bivector {
    type Output = Bivector;
    fn project(self, b: Multivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e01 * b.e01 + a.e01 * b.e012 * b.e012 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e20 * b.e012 * b.e012 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12 + a.e12 * b.e012 * b.e012,
        }
    }
}

impl Project<Scalar> for Trivector {
    type Output = Null;
    fn project(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Project<Vector> for Trivector {
    type Output = Null;
    fn project(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Bivector> for Trivector {
    type Output = Null;
    fn project(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Trivector> for Trivector {
    type Output = Trivector;
    fn project(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<Null> for Trivector {
    type Output = Trivector;
    fn project(self, b: Null) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Project<OddMultivector> for Trivector {
    type Output = Trivector;
    fn project(self, b: OddMultivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<EvenMultivector> for Trivector {
    type Output = Trivector;
    fn project(self, b: EvenMultivector) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Project<Multivector> for Trivector {
    type Output = Trivector;
    fn project(self, b: Multivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<Scalar> for Null {
    type Output = Null;
    fn project(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Project<Vector> for Null {
    type Output = Null;
    fn project(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Bivector> for Null {
    type Output = Null;
    fn project(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Trivector> for Null {
    type Output = Null;
    fn project(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Null> for Null {
    type Output = Null;
    fn project(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Project<OddMultivector> for Null {
    type Output = Null;
    fn project(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Project<EvenMultivector> for Null {
    type Output = Null;
    fn project(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Multivector> for Null {
    type Output = Null;
    fn project(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl Project<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Project<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e0 * b.e0 + a.e1 * b.e0 * b.e1 + a.e2 * b.e0 * b.e2,
            e1: a.e0 * b.e0 * b.e1 + a.e1 * b.e1 * b.e1 + a.e2 * b.e1 * b.e2,
            e2: a.e0 * b.e0 * b.e2 + a.e1 * b.e1 * b.e2 + a.e2 * b.e2 * b.e2,
            e012: 0.0,
        }
    }
}

impl Project<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e1 * b.e20 * b.e12 - a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 - a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e01 * b.e12 - a.e1 * b.e01 * b.e20 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e012: 0.0,
        }
    }
}

impl Project<Trivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e012 * b.e012,
            e1: a.e1 * b.e012 * b.e012,
            e2: a.e2 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<Null> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Project<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e0 * b.e0 + a.e0 * b.e012 * b.e012 + a.e1 * b.e0 * b.e1 + a.e2 * b.e0 * b.e2,
            e1: a.e0 * b.e0 * b.e1 + a.e1 * b.e1 * b.e1 + a.e1 * b.e012 * b.e012 + a.e2 * b.e1 * b.e2,
            e2: a.e0 * b.e0 * b.e2 + a.e1 * b.e1 * b.e2 + a.e2 * b.e2 * b.e2 + a.e2 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e1 * b.e20 * b.e12 - a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 - a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e01 * b.e12 - a.e1 * b.e01 * b.e20 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e012: 0.0,
        }
    }
}

impl Project<Multivector> for OddMultivector {
    type Output = OddMultivector;
    fn project(self, b: Multivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e0 * b.e0 + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 + a.e0 * b.e012 * b.e012 + a.e1 * b.e0 * b.e1 - a.e1 * b.e20 * b.e12 + a.e2 * b.e0 * b.e2 - a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e0 * b.e1 - a.e0 * b.e20 * b.e12 + a.e1 * b.e1 * b.e1 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 + a.e1 * b.e012 * b.e012 + a.e2 * b.e1 * b.e2 - a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e0 * b.e2 - a.e0 * b.e01 * b.e12 + a.e1 * b.e1 * b.e2 - a.e1 * b.e01 * b.e20 + a.e2 * b.e2 * b.e2 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12 + a.e2 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Project<Vector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Project<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e01: a.e01 * b.e01 * b.e01 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Project<Trivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e012 * b.e012,
            e01: a.e01 * b.e012 * b.e012,
            e20: a.e20 * b.e012 * b.e012,
            e12: a.e12 * b.e012 * b.e012,
        }
    }
}

impl Project<Null> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Project<OddMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e012 * b.e012,
            e01: a.e01 * b.e012 * b.e012,
            e20: a.e20 * b.e012 * b.e012,
            e12: a.e12 * b.e012 * b.e012,
        }
    }
}

impl Project<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e01: a.e01 * b.e01 * b.e01 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12,
        }
    }
}

impl Project<Multivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn project(self, b: Multivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s + a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 + a.s * b.e012 * b.e012,
            e01: a.e01 * b.e01 * b.e01 + a.e01 * b.e012 * b.e012 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e20 * b.e012 * b.e012 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12 + a.e12 * b.e012 * b.e012,
        }
    }
}

impl Project<Scalar> for Multivector {
    type Output = Multivector;
    fn project(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Project<Vector> for Multivector {
    type Output = Multivector;
    fn project(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2,
            e0: a.e0 * b.e0 * b.e0 + a.e1 * b.e0 * b.e1 + a.e2 * b.e0 * b.e2,
            e1: a.e0 * b.e0 * b.e1 + a.e1 * b.e1 * b.e1 + a.e2 * b.e1 * b.e2,
            e2: a.e0 * b.e0 * b.e2 + a.e1 * b.e1 * b.e2 + a.e2 * b.e2 * b.e2,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Project<Bivector> for Multivector {
    type Output = Multivector;
    fn project(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e1 * b.e20 * b.e12 - a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 - a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e01 * b.e12 - a.e1 * b.e01 * b.e20 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e01: a.e01 * b.e01 * b.e01 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12,
            e012: 0.0,
        }
    }
}

impl Project<Trivector> for Multivector {
    type Output = Multivector;
    fn project(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e012 * b.e012,
            e0: a.e0 * b.e012 * b.e012,
            e1: a.e1 * b.e012 * b.e012,
            e2: a.e2 * b.e012 * b.e012,
            e01: a.e01 * b.e012 * b.e012,
            e20: a.e20 * b.e012 * b.e012,
            e12: a.e12 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<Null> for Multivector {
    type Output = Multivector;
    fn project(self, b: Null) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Project<OddMultivector> for Multivector {
    type Output = Multivector;
    fn project(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e012 * b.e012,
            e0: a.e0 * b.e0 * b.e0 + a.e0 * b.e012 * b.e012 + a.e1 * b.e0 * b.e1 + a.e2 * b.e0 * b.e2,
            e1: a.e0 * b.e0 * b.e1 + a.e1 * b.e1 * b.e1 + a.e1 * b.e012 * b.e012 + a.e2 * b.e1 * b.e2,
            e2: a.e0 * b.e0 * b.e2 + a.e1 * b.e1 * b.e2 + a.e2 * b.e2 * b.e2 + a.e2 * b.e012 * b.e012,
            e01: a.e01 * b.e012 * b.e012,
            e20: a.e20 * b.e012 * b.e012,
            e12: a.e12 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Project<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn project(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e0: a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 - a.e1 * b.e20 * b.e12 - a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e20 * b.e12 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 - a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e01 * b.e12 - a.e1 * b.e01 * b.e20 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12,
            e01: a.e01 * b.e01 * b.e01 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12,
            e012: 0.0,
        }
    }
}

impl Project<Multivector> for Multivector {
    type Output = Multivector;
    fn project(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s + a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 + a.s * b.e012 * b.e012,
            e0: a.e0 * b.e0 * b.e0 + a.e0 * b.e01 * b.e01 + a.e0 * b.e20 * b.e20 + a.e0 * b.e012 * b.e012 + a.e1 * b.e0 * b.e1 - a.e1 * b.e20 * b.e12 + a.e2 * b.e0 * b.e2 - a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e0 * b.e1 - a.e0 * b.e20 * b.e12 + a.e1 * b.e1 * b.e1 + a.e1 * b.e01 * b.e01 + a.e1 * b.e12 * b.e12 + a.e1 * b.e012 * b.e012 + a.e2 * b.e1 * b.e2 - a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e0 * b.e2 - a.e0 * b.e01 * b.e12 + a.e1 * b.e1 * b.e2 - a.e1 * b.e01 * b.e20 + a.e2 * b.e2 * b.e2 + a.e2 * b.e20 * b.e20 + a.e2 * b.e12 * b.e12 + a.e2 * b.e012 * b.e012,
            e01: a.e01 * b.e01 * b.e01 + a.e01 * b.e012 * b.e012 + a.e20 * b.e01 * b.e20 + a.e12 * b.e01 * b.e12,
            e20: a.e01 * b.e01 * b.e20 + a.e20 * b.e20 * b.e20 + a.e20 * b.e012 * b.e012 + a.e12 * b.e20 * b.e12,
            e12: a.e01 * b.e01 * b.e12 + a.e20 * b.e20 * b.e12 + a.e12 * b.e12 * b.e12 + a.e12 * b.e012 * b.e012,
            e012: a.e012 * b.e012 * b.e012,
        }
    }
}

impl Reject<Scalar> for Scalar {
    type Output = Scalar;
    fn reject(self, b: Scalar) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s,
        }
    }
}

impl Reject<Vector> for Scalar {
    type Output = Null;
    fn reject(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Bivector> for Scalar {
    type Output = Null;
    fn reject(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Trivector> for Scalar {
    type Output = Null;
    fn reject(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Null> for Scalar {
    type Output = Scalar;
    fn reject(self, b: Null) -> Scalar {
        let a = self;
        Scalar {
            s: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Scalar {
    type Output = Scalar;
    fn reject(self, b: OddMultivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e012 * b.e012,
        }
    }
}

impl Reject<EvenMultivector> for Scalar {
    type Output = Scalar;
    fn reject(self, b: EvenMultivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
        }
    }
}

impl Reject<Multivector> for Scalar {
    type Output = Scalar;
    fn reject(self, b: Multivector) -> Scalar {
        let a = self;
        Scalar {
            s: a.s * b.s * b.s + a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 + a.s * b.e012 * b.e012,
        }
    }
}

impl Reject<Scalar> for Vector {
    type Output = Vector;
    fn reject(self, b: Scalar) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.s * b.s,
            e1: a.e1 * b.s * b.s,
            e2: a.e2 * b.s * b.s,
        }
    }
}

impl Reject<Vector> for Vector {
    type Output = Vector;
    fn reject(self, b: Vector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 - a.e1 * b.e0 * b.e1 - a.e2 * b.e0 * b.e2,
            e1: -a.e0 * b.e0 * b.e1 + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 - a.e2 * b.e1 * b.e2,
            e2: -a.e0 * b.e0 * b.e2 - a.e1 * b.e1 * b.e2 + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1,
        }
    }
}

impl Reject<Bivector> for Vector {
    type Output = Null;
    fn reject(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Trivector> for Vector {
    type Output = Null;
    fn reject(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Null> for Vector {
    type Output = Vector;
    fn reject(self, b: Null) -> Vector {
        let a = self;
        Vector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Vector {
    type Output = Vector;
    fn reject(self, b: OddMultivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 - a.e1 * b.e0 * b.e1 - a.e2 * b.e0 * b.e2,
            e1: -a.e0 * b.e0 * b.e1 + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 - a.e2 * b.e1 * b.e2,
            e2: -a.e0 * b.e0 * b.e2 - a.e1 * b.e1 * b.e2 + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1,
        }
    }
}

impl Reject<EvenMultivector> for Vector {
    type Output = Vector;
    fn reject(self, b: EvenMultivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.s * b.s + a.e0 * b.e12 * b.e12 + a.e1 * b.e20 * b.e12 + a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e20 * b.e12 + a.e1 * b.s * b.s + a.e1 * b.e20 * b.e20 + a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e01 * b.e12 + a.e1 * b.e01 * b.e20 + a.e2 * b.s * b.s + a.e2 * b.e01 * b.e01,
        }
    }
}

impl Reject<Multivector> for Vector {
    type Output = Vector;
    fn reject(self, b: Multivector) -> Vector {
        let a = self;
        Vector {
            e0: a.e0 * b.s * b.s + a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 + a.e0 * b.e12 * b.e12 - a.e1 * b.e0 * b.e1 + a.e1 * b.e20 * b.e12 - a.e2 * b.e0 * b.e2 + a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e0 * b.e1 + a.e0 * b.e20 * b.e12 + a.e1 * b.s * b.s + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 + a.e1 * b.e20 * b.e20 - a.e2 * b.e1 * b.e2 + a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e0 * b.e2 + a.e0 * b.e01 * b.e12 - a.e1 * b.e1 * b.e2 + a.e1 * b.e01 * b.e20 + a.e2 * b.s * b.s + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1 + a.e2 * b.e01 * b.e01,
        }
    }
}

impl Reject<Scalar> for Bivector {
    type Output = Bivector;
    fn reject(self, b: Scalar) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
        }
    }
}

impl Reject<Vector> for Bivector {
    type Output = Bivector;
    fn reject(self, b: Vector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.e0 * b.e0,
        }
    }
}

impl Reject<Bivector> for Bivector {
    type Output = Bivector;
    fn reject(self, b: Bivector) -> Bivector {
        let a = self;
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Reject<Trivector> for Bivector {
    type Output = Null;
    fn reject(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Null> for Bivector {
    type Output = Bivector;
    fn reject(self, b: Null) -> Bivector {
        let a = self;
        Bivector {
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Bivector {
    type Output = Bivector;
    fn reject(self, b: OddMultivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.e0 * b.e0,
        }
    }
}

impl Reject<EvenMultivector> for Bivector {
    type Output = Bivector;
    fn reject(self, b: EvenMultivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
        }
    }
}

impl Reject<Multivector> for Bivector {
    type Output = Bivector;
    fn reject(self, b: Multivector) -> Bivector {
        let a = self;
        Bivector {
            e01: a.e01 * b.s * b.s + a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.s * b.s + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.s * b.s + a.e12 * b.e0 * b.e0,
        }
    }
}

impl Reject<Scalar> for Trivector {
    type Output = Trivector;
    fn reject(self, b: Scalar) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Vector> for Trivector {
    type Output = Trivector;
    fn reject(self, b: Vector) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Reject<Bivector> for Trivector {
    type Output = Trivector;
    fn reject(self, b: Bivector) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Reject<Trivector> for Trivector {
    type Output = Trivector;
    fn reject(self, b: Trivector) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Reject<Null> for Trivector {
    type Output = Trivector;
    fn reject(self, b: Null) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Trivector {
    type Output = Trivector;
    fn reject(self, b: OddMultivector) -> Trivector {
        let a = self;
        Trivector {
            e012: 0.0,
        }
    }
}

impl Reject<EvenMultivector> for Trivector {
    type Output = Trivector;
    fn reject(self, b: EvenMultivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Multivector> for Trivector {
    type Output = Trivector;
    fn reject(self, b: Multivector) -> Trivector {
        let a = self;
        Trivector {
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Scalar> for Null {
    type Output = Null;
    fn reject(self, b: Scalar) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Vector> for Null {
    type Output = Null;
    fn reject(self, b: Vector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Bivector> for Null {
    type Output = Null;
    fn reject(self, b: Bivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Trivector> for Null {
    type Output = Null;
    fn reject(self, b: Trivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Null> for Null {
    type Output = Null;
    fn reject(self, b: Null) -> Null {
        let a = self;
        Null
    }
}

impl Reject<OddMultivector> for Null {
    type Output = Null;
    fn reject(self, b: OddMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<EvenMultivector> for Null {
    type Output = Null;
    fn reject(self, b: EvenMultivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Multivector> for Null {
    type Output = Null;
    fn reject(self, b: Multivector) -> Null {
        let a = self;
        Null
    }
}

impl Reject<Scalar> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: Scalar) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s * b.s,
            e1: a.e1 * b.s * b.s,
            e2: a.e2 * b.s * b.s,
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Vector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: Vector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 - a.e1 * b.e0 * b.e1 - a.e2 * b.e0 * b.e2,
            e1: -a.e0 * b.e0 * b.e1 + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 - a.e2 * b.e1 * b.e2,
            e2: -a.e0 * b.e0 * b.e2 - a.e1 * b.e1 * b.e2 + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1,
            e012: 0.0,
        }
    }
}

impl Reject<Bivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: Bivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e12 * b.e12 + a.e1 * b.e20 * b.e12 + a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e20 * b.e12 + a.e1 * b.e20 * b.e20 + a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e01 * b.e12 + a.e1 * b.e01 * b.e20 + a.e2 * b.e01 * b.e01,
            e012: 0.0,
        }
    }
}

impl Reject<Trivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: Trivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Reject<Null> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: Null) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e012: 0.0,
        }
    }
}

impl Reject<OddMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: OddMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 - a.e1 * b.e0 * b.e1 - a.e2 * b.e0 * b.e2,
            e1: -a.e0 * b.e0 * b.e1 + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 - a.e2 * b.e1 * b.e2,
            e2: -a.e0 * b.e0 * b.e2 - a.e1 * b.e1 * b.e2 + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1,
            e012: 0.0,
        }
    }
}

impl Reject<EvenMultivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: EvenMultivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s * b.s + a.e0 * b.e12 * b.e12 + a.e1 * b.e20 * b.e12 + a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e20 * b.e12 + a.e1 * b.s * b.s + a.e1 * b.e20 * b.e20 + a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e01 * b.e12 + a.e1 * b.e01 * b.e20 + a.e2 * b.s * b.s + a.e2 * b.e01 * b.e01,
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Multivector> for OddMultivector {
    type Output = OddMultivector;
    fn reject(self, b: Multivector) -> OddMultivector {
        let a = self;
        OddMultivector {
            e0: a.e0 * b.s * b.s + a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 + a.e0 * b.e12 * b.e12 - a.e1 * b.e0 * b.e1 + a.e1 * b.e20 * b.e12 - a.e2 * b.e0 * b.e2 + a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e0 * b.e1 + a.e0 * b.e20 * b.e12 + a.e1 * b.s * b.s + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 + a.e1 * b.e20 * b.e20 - a.e2 * b.e1 * b.e2 + a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e0 * b.e2 + a.e0 * b.e01 * b.e12 - a.e1 * b.e1 * b.e2 + a.e1 * b.e01 * b.e20 + a.e2 * b.s * b.s + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1 + a.e2 * b.e01 * b.e01,
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Scalar> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: Scalar) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s,
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
        }
    }
}

impl Reject<Vector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: Vector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2,
            e01: a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.e0 * b.e0,
        }
    }
}

impl Reject<Bivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: Bivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Reject<Trivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: Trivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e012 * b.e012,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Reject<Null> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: Null) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
        }
    }
}

impl Reject<OddMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: OddMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e012 * b.e012,
            e01: a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.e0 * b.e0,
        }
    }
}

impl Reject<EvenMultivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: EvenMultivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
        }
    }
}

impl Reject<Multivector> for EvenMultivector {
    type Output = EvenMultivector;
    fn reject(self, b: Multivector) -> EvenMultivector {
        let a = self;
        EvenMultivector {
            s: a.s * b.s * b.s + a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 + a.s * b.e012 * b.e012,
            e01: a.e01 * b.s * b.s + a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.s * b.s + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.s * b.s + a.e12 * b.e0 * b.e0,
        }
    }
}

impl Reject<Scalar> for Multivector {
    type Output = Multivector;
    fn reject(self, b: Scalar) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s,
            e0: a.e0 * b.s * b.s,
            e1: a.e1 * b.s * b.s,
            e2: a.e2 * b.s * b.s,
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Vector> for Multivector {
    type Output = Multivector;
    fn reject(self, b: Vector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2,
            e0: a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 - a.e1 * b.e0 * b.e1 - a.e2 * b.e0 * b.e2,
            e1: -a.e0 * b.e0 * b.e1 + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 - a.e2 * b.e1 * b.e2,
            e2: -a.e0 * b.e0 * b.e2 - a.e1 * b.e1 * b.e2 + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1,
            e01: a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.e0 * b.e0,
            e012: 0.0,
        }
    }
}

impl Reject<Bivector> for Multivector {
    type Output = Multivector;
    fn reject(self, b: Bivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e0: a.e0 * b.e12 * b.e12 + a.e1 * b.e20 * b.e12 + a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e20 * b.e12 + a.e1 * b.e20 * b.e20 + a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e01 * b.e12 + a.e1 * b.e01 * b.e20 + a.e2 * b.e01 * b.e01,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Reject<Trivector> for Multivector {
    type Output = Multivector;
    fn reject(self, b: Trivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e012 * b.e012,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Reject<Null> for Multivector {
    type Output = Multivector;
    fn reject(self, b: Null) -> Multivector {
        let a = self;
        Multivector {
            s: 0.0,
            e0: 0.0,
            e1: 0.0,
            e2: 0.0,
            e01: 0.0,
            e20: 0.0,
            e12: 0.0,
            e012: 0.0,
        }
    }
}

impl Reject<OddMultivector> for Multivector {
    type Output = Multivector;
    fn reject(self, b: OddMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e012 * b.e012,
            e0: a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 - a.e1 * b.e0 * b.e1 - a.e2 * b.e0 * b.e2,
            e1: -a.e0 * b.e0 * b.e1 + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 - a.e2 * b.e1 * b.e2,
            e2: -a.e0 * b.e0 * b.e2 - a.e1 * b.e1 * b.e2 + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1,
            e01: a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.e0 * b.e0,
            e012: 0.0,
        }
    }
}

impl Reject<EvenMultivector> for Multivector {
    type Output = Multivector;
    fn reject(self, b: EvenMultivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12,
            e0: a.e0 * b.s * b.s + a.e0 * b.e12 * b.e12 + a.e1 * b.e20 * b.e12 + a.e2 * b.e01 * b.e12,
            e1: a.e0 * b.e20 * b.e12 + a.e1 * b.s * b.s + a.e1 * b.e20 * b.e20 + a.e2 * b.e01 * b.e20,
            e2: a.e0 * b.e01 * b.e12 + a.e1 * b.e01 * b.e20 + a.e2 * b.s * b.s + a.e2 * b.e01 * b.e01,
            e01: a.e01 * b.s * b.s,
            e20: a.e20 * b.s * b.s,
            e12: a.e12 * b.s * b.s,
            e012: a.e012 * b.s * b.s,
        }
    }
}

impl Reject<Multivector> for Multivector {
    type Output = Multivector;
    fn reject(self, b: Multivector) -> Multivector {
        let a = self;
        Multivector {
            s: a.s * b.s * b.s + a.s * b.e0 * b.e0 + a.s * b.e1 * b.e1 + a.s * b.e2 * b.e2 + a.s * b.e01 * b.e01 + a.s * b.e20 * b.e20 + a.s * b.e12 * b.e12 + a.s * b.e012 * b.e012,
            e0: a.e0 * b.s * b.s + a.e0 * b.e1 * b.e1 + a.e0 * b.e2 * b.e2 + a.e0 * b.e12 * b.e12 - a.e1 * b.e0 * b.e1 + a.e1 * b.e20 * b.e12 - a.e2 * b.e0 * b.e2 + a.e2 * b.e01 * b.e12,
            e1: -a.e0 * b.e0 * b.e1 + a.e0 * b.e20 * b.e12 + a.e1 * b.s * b.s + a.e1 * b.e0 * b.e0 + a.e1 * b.e2 * b.e2 + a.e1 * b.e20 * b.e20 - a.e2 * b.e1 * b.e2 + a.e2 * b.e01 * b.e20,
            e2: -a.e0 * b.e0 * b.e2 + a.e0 * b.e01 * b.e12 - a.e1 * b.e1 * b.e2 + a.e1 * b.e01 * b.e20 + a.e2 * b.s * b.s + a.e2 * b.e0 * b.e0 + a.e2 * b.e1 * b.e1 + a.e2 * b.e01 * b.e01,
            e01: a.e01 * b.s * b.s + a.e01 * b.e2 * b.e2 + a.e20 * b.e1 * b.e2 + a.e12 * b.e0 * b.e2,
            e20: a.e01 * b.e1 * b.e2 + a.e20 * b.s * b.s + a.e20 * b.e1 * b.e1 + a.e12 * b.e0 * b.e1,
            e12: a.e01 * b.e0 * b.e2 + a.e20 * b.e0 * b.e1 + a.e12 * b.s * b.s + a.e12 * b.e0 * b.e0,
            e012: a.e012 * b.s * b.s,
        }
    }
}
