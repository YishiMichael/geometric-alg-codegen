use crate::ast::{Ast, Expr, ExprRepr, Implementation, Item, Ownership, Stmt, StmtRepr, Structure};
use crate::emitter::{Emitter, Stringifier, Writer};
use itertools::{Itertools, Position};

pub struct WGSLLang;

impl Emitter for WGSLLang {
    fn emit_preamble(&self, writer: &mut Writer) -> std::io::Result<()> {
        write!(
            writer.buffer(),
            "// Automatically generated by `{}`",
            env!("CARGO_PKG_NAME"),
        )?;
        writer.newline()?;
        Ok(())
    }

    fn emit_structure<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        Structure { template, fields }: &Structure<A>,
    ) -> std::io::Result<()> {
        writer.newline()?;
        write!(
            writer.buffer(),
            "struct {template} {{",
            template = stringifier.stringify_template(template),
        )?;
        {
            writer.indent();
            for Item {
                key: field,
                value: field_type,
            } in fields
            {
                writer.newline()?;
                write!(
                    writer.buffer(),
                    "{field}: {field_type},",
                    field = stringifier.stringify_field(field),
                    field_type = stringifier.stringify_type(field_type),
                )?;
            }
            if fields.is_empty() {
                writer.newline()?;
                write!(writer.buffer(), "_phantom: f32,")?;
            }
            writer.dedent();
        }
        writer.newline()?;
        write!(writer.buffer(), "}}")?;
        writer.newline()?;
        Ok(())
    }

    fn emit_implementation<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        Implementation {
            operation,
            self_type,
            generic_items,
            associate_items: _,
            self_param_item,
            param_items,
            return_type,
            body,
        }: &Implementation<A>,
    ) -> std::io::Result<()> {
        writer.newline()?;
        write!(
            writer.buffer(),
            "fn {mangled_fn}({params}){return_type} {{",
            mangled_fn = mangle(
                stringifier.stringify_operation_fn(operation),
                stringifier.stringify_type(self_type),
                generic_items.iter().map(
                    |Item {
                         key: _,
                         value: generic_type,
                     }| stringifier.stringify_type(generic_type)
                ),
            ),
            params = self_param_item
                .iter()
                .chain(param_items)
                .map(
                    |Item {
                         key: param,
                         value: param_type,
                     }| match param_type {
                        Ownership::Owned(param_type) => format!(
                            "{param}: {param_type}",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                        Ownership::Borrowed(param_type) => format!(
                            "{param}: ptr<function, {param_type}>",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                        Ownership::BorrowedMut(param_type) => format!(
                            "{param}: ptr<function, {param_type}>",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                    }
                )
                .join(", "),
            return_type = return_type
                .as_ref()
                .map(|return_type| format!(
                    " -> {return_type}",
                    return_type = stringifier.stringify_type(return_type),
                ))
                .unwrap_or_default(),
        )?;
        {
            writer.indent();
            for stmt in &body.stmts {
                writer.newline()?;
                self.emit_stmt(writer, stringifier, stmt)?;
            }
            if let Some(expr) = body.expr.as_ref() {
                writer.newline()?;
                write!(writer.buffer(), "return ")?;
                self.emit_expr(writer, stringifier, expr)?;
                write!(writer.buffer(), ";")?;
            }
            writer.dedent();
        }
        writer.newline()?;
        write!(writer.buffer(), "}}")?;
        writer.newline()?;
        Ok(())
    }

    fn emit_expr<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        expr: &Expr<A>,
    ) -> std::io::Result<()> {
        match &*expr.repr {
            ExprRepr::Variable { param } => {
                write!(writer.buffer(), "{param}")?;
            }
            ExprRepr::Literal { value } => {
                write!(writer.buffer(), "{value}.0")?;
            }
            ExprRepr::Struct { template, fields } => {
                write!(
                    writer.buffer(),
                    "{template} {{",
                    template = stringifier.stringify_template(template),
                )?;
                {
                    writer.indent();
                    for Item {
                        key: field,
                        value: field_expr,
                    } in fields
                    {
                        writer.newline()?;
                        write!(
                            writer.buffer(),
                            "{field}: ",
                            field = stringifier.stringify_field(field),
                        )?;
                        self.emit_expr(writer, stringifier, field_expr)?;
                        write!(writer.buffer(), ",")?;
                    }
                    if fields.is_empty() {
                        writer.newline()?;
                        write!(writer.buffer(), "_phantom: 0.0,")?;
                    }
                    writer.dedent();
                }
                writer.newline()?;
                write!(writer.buffer(), "}}")?;
            }
            ExprRepr::Field { expr, field } => {
                self.emit_expr(writer, stringifier, expr)?;
                write!(
                    writer.buffer(),
                    ".{field}",
                    field = stringifier.stringify_field(field)
                )?;
            }
            ExprRepr::CallBuiltin {
                operation,
                self_expr,
            } => {
                write!(
                    writer.buffer(),
                    "{operation_fn}(",
                    operation_fn = stringifier.stringify_operation_fn(operation),
                )?;
                self.emit_expr(writer, stringifier, self_expr)?;
                write!(writer.buffer(), ")")?;
            }
            ExprRepr::CallFunction {
                operation,
                self_type,
                generic_types,
                param_exprs,
            } => {
                write!(
                    writer.buffer(),
                    "{mangled_fn}(",
                    mangled_fn = mangle(
                        stringifier.stringify_operation_fn(operation),
                        stringifier.stringify_type(self_type),
                        generic_types
                            .iter()
                            .map(|generic_type| stringifier.stringify_type(generic_type)),
                    ),
                )?;
                for (position, param_expr) in param_exprs.iter().with_position() {
                    self.emit_expr(writer, stringifier, param_expr)?;
                    if matches!(position, Position::First | Position::Middle) {
                        write!(writer.buffer(), ", ")?;
                    }
                }
                write!(writer.buffer(), ")")?;
            }
            ExprRepr::CallMethod {
                operation,
                self_type,
                generic_types,
                self_expr,
                param_exprs,
            } => {
                write!(
                    writer.buffer(),
                    "{mangled_fn}(",
                    mangled_fn = mangle(
                        stringifier.stringify_operation_fn(operation),
                        stringifier.stringify_type(self_type),
                        generic_types
                            .iter()
                            .map(|generic_type| stringifier.stringify_type(generic_type)),
                    ),
                )?;
                for (position, param_expr) in std::iter::once(self_expr)
                    .chain(param_exprs)
                    .with_position()
                {
                    self.emit_expr(writer, stringifier, param_expr)?;
                    if matches!(position, Position::First | Position::Middle) {
                        write!(writer.buffer(), ", ")?;
                    }
                }
                write!(writer.buffer(), ")")?;
            }
            ExprRepr::Neg { expr } => {
                write!(writer.buffer(), "-")?;
                self.emit_expr(writer, stringifier, expr)?;
            }
            ExprRepr::Add { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " + ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Sub { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " - ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Mul { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " * ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Div { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " / ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
        }
        Ok(())
    }

    fn emit_stmt<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        stmt: &Stmt<A>,
    ) -> std::io::Result<()> {
        match &*stmt.repr {
            StmtRepr::Expr { expr } => {
                self.emit_expr(writer, stringifier, expr)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::AddAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " += ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::SubAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " -= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::MulAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " *= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::DivAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " /= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
        }
        Ok(())
    }
}

fn mangle<'s>(
    operation_fn: &'s str,
    self_type: &'s str,
    generic_types: impl IntoIterator<Item = &'s str>,
) -> String {
    [self_type, operation_fn]
        .into_iter()
        .chain(generic_types)
        .join("_")
        .to_lowercase()
}
