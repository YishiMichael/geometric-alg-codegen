use crate::ast::{
    Ast, Expr, ExprRepr, Implementation, Item, OperationName, Ownership, Stmt, StmtRepr, Structure,
};
use crate::syntax::{Stringifier, Syntax, Writer};
use itertools::{Itertools, Position};

pub struct RustLang;

impl Syntax for RustLang {
    fn emit_preamble(&self, writer: &mut Writer) -> std::io::Result<()> {
        write!(
            writer.buffer(),
            "// Automatically generated by `{}`",
            env!("CARGO_PKG_NAME"),
        )?;
        writer.newline()?;
        writer.newline()?;
        write!(writer.buffer(), "#![allow(unused_variables)]")?;
        writer.newline()?;
        writer.newline()?;
        write!(writer.buffer(), "use crate::traits::*;")?;
        writer.newline()?;
        Ok(())
    }

    fn emit_structure<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        Structure { template, fields }: &Structure<A>,
    ) -> std::io::Result<()> {
        writer.newline()?;
        write!(writer.buffer(), "#[derive(Clone, Copy, Debug, Default)]")?;
        writer.newline()?;
        if fields.is_empty() {
            write!(
                writer.buffer(),
                "pub struct {template};",
                template = stringifier.stringify_template(template),
            )?;
        } else {
            write!(
                writer.buffer(),
                "pub struct {template} {{",
                template = stringifier.stringify_template(template),
            )?;
            {
                writer.indent();
                for Item {
                    key: field,
                    value: field_type,
                } in fields
                {
                    writer.newline()?;
                    write!(
                        writer.buffer(),
                        "pub {field}: {field_type},",
                        field = stringifier.stringify_field(field),
                        field_type = stringifier.stringify_type(field_type),
                    )?;
                }
                writer.dedent();
            }
            writer.newline()?;
            write!(writer.buffer(), "}}")?;
        }
        writer.newline()?;
        Ok(())
    }

    fn emit_implementation<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        Implementation {
            operation,
            self_type,
            generic_items,
            associate_items,
            self_param_item,
            param_items,
            return_type,
            body,
        }: &Implementation<A>,
    ) -> std::io::Result<()> {
        writer.newline()?;
        write!(
            writer.buffer(),
            "impl {operation_trait}{generic_types} for {self_type} {{",
            operation_trait = operation.trait_name(),
            generic_types = if generic_items.is_empty() {
                String::new()
            } else {
                format!(
                    "<{generic_types}>",
                    generic_types = generic_items
                        .iter()
                        .map(
                            |Item {
                                 key: _,
                                 value: generic_type,
                             }| stringifier
                                .stringify_type(generic_type)
                        )
                        .join(", "),
                )
            },
            self_type = stringifier.stringify_type(self_type),
        )?;
        {
            writer.indent();
            for Item {
                key: associate,
                value: associate_type,
            } in associate_items
            {
                writer.newline()?;
                write!(
                    writer.buffer(),
                    "type {associate} = {associate_type};",
                    associate_type = stringifier.stringify_type(associate_type),
                )?;
            }
            writer.newline()?;
            write!(
                writer.buffer(),
                "fn {operation_fn}({params}){return_type} {{",
                operation_fn = operation.fn_name(),
                params = self_param_item
                    .iter()
                    .map(
                        |Item {
                             key: self_param,
                             value: self_param_type,
                         }| match self_param_type {
                            Ownership::Owned(_) => format!("{self_param}"),
                            Ownership::Borrowed(_) => format!("&{self_param}"),
                            Ownership::BorrowedMut(_) => format!("&mut {self_param}"),
                        }
                    )
                    .chain(param_items.iter().map(
                        |Item {
                             key: param,
                             value: param_type,
                         }| match param_type {
                            Ownership::Owned(param_type) => format!(
                                "{param}: {param_type}",
                                param_type = stringifier.stringify_type(param_type),
                            ),
                            Ownership::Borrowed(param_type) => format!(
                                "{param}: &{param_type}",
                                param_type = stringifier.stringify_type(param_type),
                            ),
                            Ownership::BorrowedMut(param_type) => format!(
                                "{param}: &mut {param_type}",
                                param_type = stringifier.stringify_type(param_type),
                            ),
                        }
                    ))
                    .join(", "),
                return_type = return_type
                    .as_ref()
                    .map(|return_type| format!(
                        " -> {return_type}",
                        return_type = stringifier.stringify_type(return_type),
                    ))
                    .unwrap_or_default(),
            )?;
            {
                writer.indent();
                for stmt in &body.stmts {
                    writer.newline()?;
                    self.emit_stmt(writer, stringifier, stmt)?;
                }
                if let Some(expr) = body.expr.as_ref() {
                    writer.newline()?;
                    self.emit_expr(writer, stringifier, expr)?;
                }
                writer.dedent();
            }
            writer.newline()?;
            write!(writer.buffer(), "}}")?;
            writer.dedent();
        }
        writer.newline()?;
        write!(writer.buffer(), "}}")?;
        writer.newline()?;
        Ok(())
    }

    fn emit_expr<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        expr: &Expr<A>,
    ) -> std::io::Result<()> {
        match &*expr.repr {
            ExprRepr::Variable { param } => {
                write!(writer.buffer(), "{param}")?;
            }
            ExprRepr::Literal { value } => {
                write!(writer.buffer(), "{value}.0")?;
            }
            ExprRepr::Struct { template, fields } => {
                if fields.is_empty() {
                    write!(
                        writer.buffer(),
                        "{template}",
                        template = stringifier.stringify_template(template),
                    )?;
                } else {
                    write!(
                        writer.buffer(),
                        "{template} {{",
                        template = stringifier.stringify_template(template),
                    )?;
                    {
                        writer.indent();
                        for Item {
                            key: field,
                            value: field_expr,
                        } in fields
                        {
                            writer.newline()?;
                            write!(
                                writer.buffer(),
                                "{field}: ",
                                field = stringifier.stringify_field(field),
                            )?;
                            self.emit_expr(writer, stringifier, field_expr)?;
                            write!(writer.buffer(), ",")?;
                        }
                        writer.dedent();
                    }
                    writer.newline()?;
                    write!(writer.buffer(), "}}")?;
                }
            }
            ExprRepr::Field { expr, field } => {
                self.emit_expr(writer, stringifier, expr)?;
                write!(
                    writer.buffer(),
                    ".{field}",
                    field = stringifier.stringify_field(field)
                )?;
            }
            ExprRepr::Deref { expr } => {
                write!(writer.buffer(), "*")?;
                self.emit_expr(writer, stringifier, expr)?;
            }
            ExprRepr::Call {
                operation,
                self_type,
                generic_types: _,
                self_expr,
                param_exprs,
            } => {
                if let Some(self_expr) = self_expr {
                    self.emit_expr(writer, stringifier, self_expr)?;
                    write!(
                        writer.buffer(),
                        ".{operation_fn}",
                        operation_fn = operation.fn_name(),
                    )?;
                } else {
                    write!(
                        writer.buffer(),
                        "{self_type}::{operation_fn}",
                        self_type = stringifier.stringify_type(self_type),
                        operation_fn = operation.fn_name(),
                    )?;
                }
                write!(writer.buffer(), "(")?;
                for (position, param_expr) in param_exprs.iter().with_position() {
                    self.emit_expr(writer, stringifier, param_expr)?;
                    if matches!(position, Position::First | Position::Middle) {
                        write!(writer.buffer(), ", ")?;
                    }
                }
                write!(writer.buffer(), ")")?;
            }
            ExprRepr::Neg { expr } => {
                write!(writer.buffer(), "-")?;
                self.emit_expr(writer, stringifier, expr)?;
            }
            ExprRepr::Add { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " + ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Sub { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " - ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Mul { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " * ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Div { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " / ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
        }
        Ok(())
    }

    fn emit_stmt<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        stmt: &Stmt<A>,
    ) -> std::io::Result<()> {
        match &*stmt.repr {
            StmtRepr::Expr { expr } => {
                self.emit_expr(writer, stringifier, expr)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::AddAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " += ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::SubAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " -= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::MulAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " *= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::DivAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " /= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
        }
        Ok(())
    }
}
