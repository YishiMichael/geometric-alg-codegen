use crate::ast::{
    Ast, Expr, ExprRepr, Implementation, Item, OperationName, Ownership, Stmt, StmtRepr, Structure,
};
use crate::syntax::{Stringifier, Syntax, Writer};
use itertools::{Itertools, Position};

pub struct GLSLLang;

impl Syntax for GLSLLang {
    fn emit_preamble(&self, writer: &mut Writer) -> std::io::Result<()> {
        write!(
            writer.buffer(),
            "// Automatically generated by `{}`",
            env!("CARGO_PKG_NAME"),
        )?;
        writer.newline()?;
        Ok(())
    }

    fn emit_structure<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        Structure { template, fields }: &Structure<A>,
    ) -> std::io::Result<()> {
        writer.newline()?;
        write!(
            writer.buffer(),
            "struct {template} {{",
            template = stringifier.stringify_template(template),
        )?;
        {
            writer.indent();
            for Item {
                key: field,
                value: field_type,
            } in fields
            {
                writer.newline()?;
                write!(
                    writer.buffer(),
                    "{field_type} {field};",
                    field_type = stringifier.stringify_type(field_type),
                    field = stringifier.stringify_field(field),
                )?;
            }
            if fields.is_empty() {
                writer.newline()?;
                write!(writer.buffer(), "float _phantom;")?;
            }
            writer.dedent();
        }
        writer.newline()?;
        write!(writer.buffer(), "}};")?;
        writer.newline()?;
        Ok(())
    }

    fn emit_implementation<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        Implementation {
            operation,
            self_type,
            generic_items,
            associate_items: _,
            self_param_item,
            param_items,
            return_type,
            body,
        }: &Implementation<A>,
    ) -> std::io::Result<()> {
        writer.newline()?;
        write!(
            writer.buffer(),
            "{return_type} {mangled_fn}({params}) {{",
            return_type = return_type
                .as_ref()
                .map(|return_type| stringifier.stringify_type(return_type))
                .unwrap_or("void"),
            mangled_fn = mangle(
                operation,
                stringifier.stringify_type(self_type),
                generic_items.iter().map(
                    |Item {
                         key: _,
                         value: generic_type,
                     }| stringifier.stringify_type(generic_type)
                ),
            ),
            params = self_param_item
                .iter()
                .chain(param_items)
                .map(
                    |Item {
                         key: param,
                         value: param_type,
                     }| match param_type {
                        Ownership::Owned(param_type) => format!(
                            "{param_type} {param}",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                        Ownership::Borrowed(param_type) => format!(
                            "{param_type} {param}",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                        Ownership::BorrowedMut(param_type) => format!(
                            "inout {param_type} {param}",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                    }
                )
                .join(", "),
        )?;
        {
            writer.indent();
            for stmt in &body.stmts {
                writer.newline()?;
                self.emit_stmt(writer, stringifier, stmt)?;
            }
            if let Some(expr) = body.expr.as_ref() {
                writer.newline()?;
                write!(writer.buffer(), "return ")?;
                self.emit_expr(writer, stringifier, expr)?;
                write!(writer.buffer(), ";")?;
            }
            writer.dedent();
        }
        writer.newline()?;
        write!(writer.buffer(), "}}")?;
        writer.newline()?;
        Ok(())
    }

    fn emit_expr<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        expr: &Expr<A>,
    ) -> std::io::Result<()> {
        match &*expr.repr {
            ExprRepr::Variable { param } => {
                write!(writer.buffer(), "{param}")?;
            }
            ExprRepr::Literal { value } => {
                write!(writer.buffer(), "{value}.0")?;
            }
            ExprRepr::Struct { template, fields } => {
                write!(
                    writer.buffer(),
                    "{template}(",
                    template = stringifier.stringify_template(template),
                )?;
                {
                    writer.indent();
                    for (
                        position,
                        Item {
                            key: _,
                            value: field_expr,
                        },
                    ) in fields.iter().with_position()
                    {
                        writer.newline()?;
                        self.emit_expr(writer, stringifier, field_expr)?;
                        if matches!(position, Position::First | Position::Middle) {
                            write!(writer.buffer(), ",")?;
                        }
                    }
                    if fields.is_empty() {
                        writer.newline()?;
                        write!(writer.buffer(), "0.0")?;
                    }
                    writer.dedent();
                }
                writer.newline()?;
                write!(writer.buffer(), ")")?;
            }
            ExprRepr::Field { expr, field } => {
                self.emit_expr(writer, stringifier, expr)?;
                write!(
                    writer.buffer(),
                    ".{field}",
                    field = stringifier.stringify_field(field)
                )?;
            }
            ExprRepr::Deref { expr } => {
                self.emit_expr(writer, stringifier, expr)?;
            }
            ExprRepr::Call {
                operation,
                self_type,
                generic_types,
                self_expr,
                param_exprs,
            } => {
                write!(
                    writer.buffer(),
                    "{mangled_fn}(",
                    mangled_fn = mangle(
                        operation,
                        stringifier.stringify_type(self_type),
                        generic_types
                            .iter()
                            .map(|generic_type| stringifier.stringify_type(generic_type)),
                    ),
                )?;
                for (position, param_expr) in self_expr.iter().chain(param_exprs).with_position() {
                    self.emit_expr(writer, stringifier, param_expr)?;
                    if matches!(position, Position::First | Position::Middle) {
                        write!(writer.buffer(), ", ")?;
                    }
                }
                write!(writer.buffer(), ")")?;
            }
            ExprRepr::Neg { expr } => {
                write!(writer.buffer(), "-")?;
                self.emit_expr(writer, stringifier, expr)?;
            }
            ExprRepr::Add { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " + ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Sub { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " - ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Mul { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " * ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
            ExprRepr::Div { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " / ")?;
                self.emit_expr(writer, stringifier, rhs)?;
            }
        }
        Ok(())
    }

    fn emit_stmt<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        stmt: &Stmt<A>,
    ) -> std::io::Result<()> {
        match &*stmt.repr {
            StmtRepr::Expr { expr } => {
                self.emit_expr(writer, stringifier, expr)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::Let {
                param,
                param_type,
                expr,
            } => {
                write!(
                    writer.buffer(),
                    "{param_type} {param} = ",
                    param_type = stringifier.stringify_type(param_type),
                )?;
                self.emit_expr(writer, stringifier, expr)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::LetMut {
                param,
                param_type,
                expr,
            } => {
                write!(
                    writer.buffer(),
                    "{param_type} {param} = ",
                    param_type = stringifier.stringify_type(param_type),
                )?;
                self.emit_expr(writer, stringifier, expr)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::Assign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " = ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::AddAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " += ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::SubAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " -= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::MulAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " *= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
            StmtRepr::DivAssign { lhs, rhs } => {
                self.emit_expr(writer, stringifier, lhs)?;
                write!(writer.buffer(), " /= ")?;
                self.emit_expr(writer, stringifier, rhs)?;
                write!(writer.buffer(), ";")?;
            }
        }
        Ok(())
    }
}

fn mangle<'s>(
    operation: &'s impl OperationName,
    self_type: &'s str,
    generic_types: impl IntoIterator<Item = &'s str>,
) -> String {
    if operation.is_builtin() {
        operation.fn_name().to_lowercase()
    } else {
        [self_type, operation.fn_name()]
            .into_iter()
            .chain(generic_types)
            .join("_")
            .to_lowercase()
    }
}
