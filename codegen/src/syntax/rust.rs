use crate::ast::{
    Ast, Expr, ExprRepr, Implementation, Item, OperationName, Ownership, Record, Stmt, StmtRepr,
    Structure,
};
use crate::syntax::{Stringifier, Syntax, Writer};
use itertools::{Itertools, Position};

pub struct RustLang;

impl Syntax for RustLang {
    fn emit_record<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        record: &Record<A>,
    ) -> std::io::Result<()> {
        write!(
            writer.buffer(),
            "// Automatically generated by `{}`",
            env!("CARGO_PKG_NAME"),
        )?;
        writer.newline()?;
        writer.newline()?;
        write!(writer.buffer(), "#![allow(unused_variables)]")?;
        writer.newline()?;
        writer.newline()?;
        write!(writer.buffer(), "use crate::traits::*;")?;
        writer.newline()?;
        for structure in &record.structures {
            writer.newline()?;
            emit_structure(writer, stringifier, structure)?;
        }
        for implementation in &record.implementations {
            writer.newline()?;
            emit_implementation(writer, stringifier, implementation)?;
        }
        Ok(())
    }
}

fn emit_structure<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    Structure { template, fields }: &Structure<A>,
) -> std::io::Result<()> {
    write!(writer.buffer(), "#[derive(Clone, Copy, Debug, Default)]")?;
    writer.newline()?;
    if fields.is_empty() {
        write!(
            writer.buffer(),
            "pub struct {template};",
            template = stringifier.stringify_template(template),
        )?;
    } else {
        write!(
            writer.buffer(),
            "pub struct {template} {{",
            template = stringifier.stringify_template(template),
        )?;
        {
            writer.indent();
            for Item {
                key: field,
                value: field_type,
            } in fields
            {
                writer.newline()?;
                write!(
                    writer.buffer(),
                    "pub {field}: {field_type},",
                    field = stringifier.stringify_field(field),
                    field_type = stringifier.stringify_type(field_type),
                )?;
            }
            writer.dedent();
        }
        writer.newline()?;
        write!(writer.buffer(), "}}")?;
    }
    writer.newline()?;
    Ok(())
}

fn emit_implementation<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    Implementation {
        operation,
        self_type,
        generic_items,
        associate_items,
        self_param_item,
        param_items,
        return_type,
        body,
    }: &Implementation<A>,
) -> std::io::Result<()> {
    write!(
        writer.buffer(),
        "impl {operation_trait}{generic_types} for {self_type} {{",
        operation_trait = operation.trait_name(),
        generic_types = if generic_items.is_empty() {
            String::new()
        } else {
            format!(
                "<{generic_types}>",
                generic_types = generic_items
                    .iter()
                    .map(
                        |Item {
                             key: _,
                             value: generic_type,
                         }| stringifier.stringify_type(generic_type)
                    )
                    .join(", "),
            )
        },
        self_type = stringifier.stringify_type(self_type),
    )?;
    {
        writer.indent();
        for Item {
            key: associate,
            value: associate_type,
        } in associate_items
        {
            writer.newline()?;
            write!(
                writer.buffer(),
                "type {associate} = {associate_type};",
                associate_type = stringifier.stringify_type(associate_type),
            )?;
        }
        writer.newline()?;
        write!(
            writer.buffer(),
            "fn {operation_fn}({params}){return_type} {{",
            operation_fn = operation.fn_name(),
            params = self_param_item
                .iter()
                .map(
                    |Item {
                         key: _,
                         value: self_param_type,
                     }| {
                        match self_param_type {
                            Ownership::Owned(_) => String::from("self"),
                            Ownership::Borrowed(_) => String::from("&self"),
                            Ownership::BorrowedMut(_) => String::from("&mut self"),
                        }
                    }
                )
                .chain(param_items.iter().map(
                    |Item {
                         key: param,
                         value: param_type,
                     }| match param_type {
                        Ownership::Owned(param_type) => format!(
                            "{param}: {param_type}",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                        Ownership::Borrowed(param_type) => format!(
                            "{param}: &{param_type}",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                        Ownership::BorrowedMut(param_type) => format!(
                            "{param}: &mut {param_type}",
                            param_type = stringifier.stringify_type(param_type),
                        ),
                    }
                ))
                .join(", "),
            return_type = return_type
                .as_ref()
                .map(|return_type| format!(
                    " -> {return_type}",
                    return_type = stringifier.stringify_type(return_type),
                ))
                .unwrap_or_default(),
        )?;
        {
            writer.indent();
            if let Some(Item {
                key: self_param,
                value: _,
            }) = self_param_item.as_ref()
            {
                writer.newline()?;
                write!(writer.buffer(), "let {self_param} = self;")?;
            }
            for stmt in &body.stmts {
                writer.newline()?;
                emit_stmt(writer, stringifier, stmt)?;
            }
            if let Some(expr) = body.expr.as_ref() {
                writer.newline()?;
                emit_expr(writer, stringifier, expr)?;
            }
            writer.dedent();
        }
        writer.newline()?;
        write!(writer.buffer(), "}}")?;
        writer.dedent();
    }
    writer.newline()?;
    write!(writer.buffer(), "}}")?;
    writer.newline()?;
    Ok(())
}

fn emit_expr<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    expr: &Expr<A>,
) -> std::io::Result<()> {
    match &*expr.repr {
        ExprRepr::Variable { param } => {
            write!(writer.buffer(), "{param}")?;
        }
        ExprRepr::Literal { value } => {
            write!(writer.buffer(), "{value}.0")?;
        }
        ExprRepr::Struct { template, fields } => {
            if fields.is_empty() {
                write!(
                    writer.buffer(),
                    "{template}",
                    template = stringifier.stringify_template(template),
                )?;
            } else {
                write!(
                    writer.buffer(),
                    "{template} {{",
                    template = stringifier.stringify_template(template),
                )?;
                {
                    writer.indent();
                    for Item {
                        key: field,
                        value: field_expr,
                    } in fields
                    {
                        writer.newline()?;
                        write!(
                            writer.buffer(),
                            "{field}: ",
                            field = stringifier.stringify_field(field),
                        )?;
                        emit_expr(writer, stringifier, field_expr)?;
                        write!(writer.buffer(), ",")?;
                    }
                    writer.dedent();
                }
                writer.newline()?;
                write!(writer.buffer(), "}}")?;
            }
        }
        ExprRepr::Field { expr, field } => {
            emit_expr(writer, stringifier, expr)?;
            write!(
                writer.buffer(),
                ".{field}",
                field = stringifier.stringify_field(field)
            )?;
        }
        ExprRepr::Borrow { expr } => {
            write!(writer.buffer(), "&")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::BorrowMut { expr } => {
            write!(writer.buffer(), "&mut ")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::Deref { expr } => {
            write!(writer.buffer(), "*")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::Call {
            operation,
            self_type,
            generic_types: _,
            self_expr,
            param_exprs,
        } => {
            if let Some(self_expr) = self_expr {
                emit_expr(
                    writer,
                    stringifier,
                    match &*self_expr.repr {
                        ExprRepr::Borrow { expr } => expr,
                        ExprRepr::BorrowMut { expr } => expr,
                        ExprRepr::Deref { expr } => expr,
                        _ => self_expr,
                    },
                )?;
                write!(
                    writer.buffer(),
                    ".{operation_fn}",
                    operation_fn = operation.fn_name(),
                )?;
            } else {
                write!(
                    writer.buffer(),
                    "{self_type}::{operation_fn}",
                    self_type = stringifier.stringify_type(self_type),
                    operation_fn = operation.fn_name(),
                )?;
            }
            write!(writer.buffer(), "(")?;
            for (position, param_expr) in param_exprs.iter().with_position() {
                emit_expr(writer, stringifier, param_expr)?;
                if matches!(position, Position::First | Position::Middle) {
                    write!(writer.buffer(), ", ")?;
                }
            }
            write!(writer.buffer(), ")")?;
        }
        ExprRepr::Neg { expr } => {
            write!(writer.buffer(), "-")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::Add { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " + ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
        ExprRepr::Sub { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " - ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
        ExprRepr::Mul { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " * ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
        ExprRepr::Div { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " / ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
    }
    Ok(())
}

fn emit_stmt<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    stmt: &Stmt<A>,
) -> std::io::Result<()> {
    match &*stmt.repr {
        StmtRepr::Expr { expr } => {
            emit_expr(writer, stringifier, expr)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::Let {
            param,
            param_type: _,
            expr,
        } => {
            write!(writer.buffer(), "let {param} = ")?;
            emit_expr(writer, stringifier, expr)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::LetMut {
            param,
            param_type: _,
            expr,
        } => {
            write!(writer.buffer(), "let mut {param} = ")?;
            emit_expr(writer, stringifier, expr)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::Assign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " = ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::AddAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " += ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::SubAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " -= ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::MulAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " *= ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::DivAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " /= ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
    }
    Ok(())
}
