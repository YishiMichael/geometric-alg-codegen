use crate::ast::{
    Ast, Expr, ExprRepr, Implementation, Item, OperationName, Ownership, Record, Stmt, StmtRepr,
    Structure,
};
use crate::syntax::{Stringifier, Syntax, Writer};
use itertools::{Itertools, Position};

pub struct WGSLLang;

impl Syntax for WGSLLang {
    fn emit_record<A: Ast>(
        &self,
        writer: &mut Writer,
        stringifier: &dyn Stringifier<A>,
        record: &Record<A>,
    ) -> std::io::Result<()> {
        write!(
            writer.buffer(),
            "// Automatically generated by `{}`",
            env!("CARGO_PKG_NAME"),
        )?;
        writer.newline()?;
        for structure in &record.structures {
            writer.newline()?;
            emit_structure(writer, stringifier, structure)?;
        }
        for implementation in &record.implementations {
            writer.newline()?;
            emit_implementation(writer, stringifier, implementation)?;
        }
        Ok(())
    }
}

fn emit_structure<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    Structure { template, fields }: &Structure<A>,
) -> std::io::Result<()> {
    write!(
        writer.buffer(),
        "struct {template} {{",
        template = stringifier.stringify_template(template),
    )?;
    {
        writer.indent();
        for Item {
            key: field,
            value: field_type,
        } in fields
        {
            writer.newline()?;
            write!(
                writer.buffer(),
                "{field}: {field_type},",
                field = stringifier.stringify_field(field),
                field_type = stringifier.stringify_type(field_type),
            )?;
        }
        if fields.is_empty() {
            writer.newline()?;
            write!(writer.buffer(), "_phantom: i32,")?;
        }
        writer.dedent();
    }
    writer.newline()?;
    write!(writer.buffer(), "}}")?;
    writer.newline()?;
    Ok(())
}

fn emit_implementation<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    Implementation {
        operation,
        self_type,
        generic_items,
        associate_items: _,
        self_param_item,
        param_items,
        return_type,
        body,
    }: &Implementation<A>,
) -> std::io::Result<()> {
    write!(
        writer.buffer(),
        "fn {mangled_fn}({params}){return_type} {{",
        mangled_fn = mangle(
            operation,
            stringifier.stringify_type(self_type),
            generic_items.iter().map(
                |Item {
                     key: _,
                     value: generic_type,
                 }| stringifier.stringify_type(generic_type)
            ),
        ),
        params = self_param_item
            .iter()
            .chain(param_items)
            .map(
                |Item {
                     key: param,
                     value: param_type,
                 }| match param_type {
                    Ownership::Owned(param_type) => format!(
                        "{param}: {param_type}",
                        param_type = stringifier.stringify_type(param_type),
                    ),
                    Ownership::Borrowed(param_type) => format!(
                        "{param}: ptr<function, {param_type}>",
                        param_type = stringifier.stringify_type(param_type),
                    ),
                    Ownership::BorrowedMut(param_type) => format!(
                        "{param}: ptr<function, {param_type}>",
                        param_type = stringifier.stringify_type(param_type),
                    ),
                }
            )
            .join(", "),
        return_type = return_type
            .as_ref()
            .map(|return_type| format!(
                " -> {return_type}",
                return_type = stringifier.stringify_type(return_type),
            ))
            .unwrap_or_default(),
    )?;
    {
        writer.indent();
        for stmt in &body.stmts {
            writer.newline()?;
            emit_stmt(writer, stringifier, stmt)?;
        }
        if let Some(expr) = body.expr.as_ref() {
            writer.newline()?;
            write!(writer.buffer(), "return ")?;
            emit_expr(writer, stringifier, expr)?;
            write!(writer.buffer(), ";")?;
        }
        writer.dedent();
    }
    writer.newline()?;
    write!(writer.buffer(), "}}")?;
    writer.newline()?;
    Ok(())
}

fn emit_expr<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    expr: &Expr<A>,
) -> std::io::Result<()> {
    match &*expr.repr {
        ExprRepr::Variable { param } => {
            write!(writer.buffer(), "{param}")?;
        }
        ExprRepr::Literal { value } => {
            write!(writer.buffer(), "{value}.0")?;
        }
        ExprRepr::Struct { template, fields } => {
            write!(
                writer.buffer(),
                "{template}(",
                template = stringifier.stringify_template(template),
            )?;
            {
                writer.indent();
                for Item {
                    key: _,
                    value: field_expr,
                } in fields
                {
                    writer.newline()?;
                    emit_expr(writer, stringifier, field_expr)?;
                    write!(writer.buffer(), ",")?;
                }
                if fields.is_empty() {
                    writer.newline()?;
                    write!(writer.buffer(), "0,")?;
                }
                writer.dedent();
            }
            writer.newline()?;
            write!(writer.buffer(), ")")?;
        }
        ExprRepr::Field { expr, field } => {
            emit_expr(writer, stringifier, expr)?;
            write!(
                writer.buffer(),
                ".{field}",
                field = stringifier.stringify_field(field)
            )?;
        }
        ExprRepr::Borrow { expr } => {
            write!(writer.buffer(), "&")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::BorrowMut { expr } => {
            write!(writer.buffer(), "&")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::Deref { expr } => {
            write!(writer.buffer(), "*")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::Call {
            operation,
            self_type,
            generic_types,
            self_expr,
            param_exprs,
        } => {
            write!(
                writer.buffer(),
                "{mangled_fn}(",
                mangled_fn = mangle(
                    operation,
                    stringifier.stringify_type(self_type),
                    generic_types
                        .iter()
                        .map(|generic_type| stringifier.stringify_type(generic_type)),
                ),
            )?;
            for (position, param_expr) in self_expr.iter().chain(param_exprs).with_position() {
                emit_expr(writer, stringifier, param_expr)?;
                if matches!(position, Position::First | Position::Middle) {
                    write!(writer.buffer(), ", ")?;
                }
            }
            write!(writer.buffer(), ")")?;
        }
        ExprRepr::Neg { expr } => {
            write!(writer.buffer(), "-")?;
            emit_expr(writer, stringifier, expr)?;
        }
        ExprRepr::Add { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " + ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
        ExprRepr::Sub { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " - ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
        ExprRepr::Mul { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " * ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
        ExprRepr::Div { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " / ")?;
            emit_expr(writer, stringifier, rhs)?;
        }
    }
    Ok(())
}

fn emit_stmt<A: Ast>(
    writer: &mut Writer,
    stringifier: &dyn Stringifier<A>,
    stmt: &Stmt<A>,
) -> std::io::Result<()> {
    match &*stmt.repr {
        StmtRepr::Expr { expr } => {
            emit_expr(writer, stringifier, expr)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::Let {
            param,
            param_type,
            expr,
        } => {
            write!(
                writer.buffer(),
                "let {param}: {param_type} = ",
                param_type = stringifier.stringify_type(param_type),
            )?;
            emit_expr(writer, stringifier, expr)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::LetMut {
            param,
            param_type,
            expr,
        } => {
            write!(
                writer.buffer(),
                "var {param}: {param_type} = ",
                param_type = stringifier.stringify_type(param_type),
            )?;
            emit_expr(writer, stringifier, expr)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::Assign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " = ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::AddAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " += ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::SubAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " -= ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::MulAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " *= ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
        StmtRepr::DivAssign { lhs, rhs } => {
            emit_expr(writer, stringifier, lhs)?;
            write!(writer.buffer(), " /= ")?;
            emit_expr(writer, stringifier, rhs)?;
            write!(writer.buffer(), ";")?;
        }
    }
    Ok(())
}

fn mangle<'s>(
    operation: &'s impl OperationName,
    self_type: &'s str,
    generic_types: impl IntoIterator<Item = &'s str>,
) -> String {
    if operation.is_builtin() {
        operation.fn_name().to_lowercase()
    } else {
        [self_type, operation.fn_name()]
            .into_iter()
            .chain(generic_types)
            .map(|s| s.replace('_', ""))
            .join("_")
            .to_lowercase()
    }
}
